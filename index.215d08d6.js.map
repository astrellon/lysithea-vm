{"mappings":"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","sources":["src/common.ts","node_modules/lysithea-vm/src/values/builtinFunctionValue.ts","node_modules/lysithea-vm/src/values/numberValue.ts","node_modules/lysithea-vm/src/scope.ts","node_modules/lysithea-vm/src/values/boolValue.ts","node_modules/lysithea-vm/src/values/stringValue.ts","node_modules/lysithea-vm/src/values/arrayValue.ts","node_modules/lysithea-vm/src/values/ivalues.ts","node_modules/lysithea-vm/src/values/nullValue.ts","node_modules/lysithea-vm/src/values/objectValue.ts","node_modules/lysithea-vm/src/standardLibrary/standardArrayLibrary.ts","node_modules/lysithea-vm/src/values/variableValue.ts","node_modules/lysithea-vm/src/values/valuePropertyAccess.ts","node_modules/lysithea-vm/src/vmFunction.ts","node_modules/lysithea-vm/src/virtualMachine.ts","node_modules/lysithea-vm/src/parser.ts","node_modules/lysithea-vm/src/script.ts","node_modules/lysithea-vm/src/values/functionValue.ts","node_modules/lysithea-vm/src/assembler.ts","node_modules/lysithea-vm/src/standardLibrary/standardMathLibrary.ts","node_modules/lysithea-vm/src/standardLibrary/standardStringLibrary.ts","node_modules/lysithea-vm/src/standardLibrary/standardObjectLibrary.ts","node_modules/lysithea-vm/src/standardLibrary/standardMiscLibrary.ts","node_modules/lysithea-vm/src/standardLibrary/index.ts","src/standardLibVM.ts","src/randomLibrary.ts","src/pageSetupVM.ts","src/perfTestVM.ts"],"sourcesContent":["export interface CodeContext\n{\n    readonly output: HTMLElement;\n    readonly text: string;\n}\n\nexport function getTextFor(codeId: string) : CodeContext | false\n{\n    const textEl = document.getElementById(codeId) as HTMLTextAreaElement;\n    const output = document.getElementById(codeId + '_output');\n    if (textEl == null || output == null)\n    {\n        alert('Broken code example, unable to find code id: ' + codeId);\n        return false;\n    }\n\n    const text = textEl?.value;\n    if (!text)\n    {\n        output.innerHTML = 'Needs text input to parse';\n        return false;\n    }\n    output.innerHTML = '';\n\n    return { output, text };\n}","import { VirtualMachine } from \"../virtualMachine\";\nimport { ArrayValue } from \"./arrayValue\";\nimport { CompareResult, IFunctionValue, IValue } from \"./ivalues\";\n\nexport type BuiltinFunctionCallback = (vm: VirtualMachine, args: ArrayValue) => void;\n\nexport class BuiltinFunctionValue implements IFunctionValue\n{\n    public readonly value: BuiltinFunctionCallback;\n    public readonly name: string;\n\n    constructor (value: BuiltinFunctionCallback, name: string)\n    {\n        this.value = value;\n        this.name = name;\n    }\n\n    public typename() { return 'builtin-function'; }\n    public toString() { return `builtin-function:${this.name}`; }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if (!(other instanceof BuiltinFunctionValue)) { return 1; }\n\n        return this.value === other.value ? 0 : 1;\n    }\n\n    public invoke(vm: VirtualMachine, args: ArrayValue, pushToStackTrace: boolean)\n    {\n        this.value(vm, args);\n    }\n}","import { CompareResult, IValue } from \"./ivalues\";\n\nexport class NumberValue implements IValue\n{\n    public readonly value: number;\n\n    constructor (value: number)\n    {\n        this.value = value;\n    }\n\n    public typename() { return 'number'; }\n    public toString() { return this.value.toString(); }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if (!(other instanceof NumberValue))\n        {\n            return 1;\n        }\n\n        return numberCompareTo(this.value, other.value);\n    }\n}\n\nexport function numberCompareTo(left: number, right: number) : CompareResult\n{\n    const diff = left - right;\n    if (Math.abs(diff) < 0.0001)\n    {\n        return 0;\n    }\n\n    if (diff < 0)\n    {\n        return -1;\n    }\n\n    return 1;\n}\n\nexport function isNumberValue(input: IValue | undefined): input is NumberValue\n{\n    return input instanceof NumberValue;\n}","import { BuiltinFunctionValue, BuiltinFunctionCallback } from \"./values/builtinFunctionValue\";\nimport { IValue } from \"./values/ivalues\";\nimport { isNumberValue } from \"./values/numberValue\";\n\nexport interface ScopeData\n{\n    [key: string]: IValue;\n}\n\nexport interface IReadOnlyScope\n{\n    readonly get: (key: string) => IValue | undefined;\n    get values(): Readonly<ScopeData>;\n}\n\nexport class Scope implements IReadOnlyScope\n{\n    public static readonly Empty: IReadOnlyScope = new Scope(undefined);\n\n    private readonly _values: ScopeData = {};\n    private readonly _parent: Scope | undefined;\n\n    public get values(): Readonly<ScopeData>\n    {\n        return this._values;\n    }\n\n    constructor(parent: Scope | undefined = undefined)\n    {\n        this._parent = parent;\n    }\n\n    public combineScope(input: IReadOnlyScope)\n    {\n        for (const prop in input.values)\n        {\n            this.define(prop, input.values[prop]);\n        }\n    }\n\n    public define(key: string, value: IValue)\n    {\n        this._values[key] = value;\n    }\n\n    public defineFunc(key: string, value: BuiltinFunctionCallback, name: string | null = null)\n    {\n        this._values[key] = new BuiltinFunctionValue(value, name ?? key);\n    }\n\n    public set(key: string, value: IValue): boolean\n    {\n        if (this._values.hasOwnProperty(key))\n        {\n            this._values[key] = value;\n            return true;\n        }\n\n        if (this._parent)\n        {\n            return this._parent.set(key, value);\n        }\n\n        return false;\n    }\n\n    public get(key: string): IValue | undefined\n    {\n        const result = this._values[key];\n        if (result != null)\n        {\n            return result;\n        }\n\n        if (this._parent !== undefined)\n        {\n            return this._parent.get(key);\n        }\n\n        return undefined;\n    }\n\n    public getNumber(key: string): number | undefined\n    {\n        const result = this.get(key);\n        if (isNumberValue(result))\n        {\n            return result.value;\n        }\n\n        return undefined;\n    }\n}","import { CompareResult, IValue } from \"./ivalues\";\n\nexport class BoolValue implements IValue\n{\n    public static readonly True: BoolValue = new BoolValue(true);\n    public static readonly False: BoolValue = new BoolValue(false);\n\n    public readonly value: boolean;\n\n    constructor (value: boolean)\n    {\n        this.value = value;\n    }\n\n    public typename() { return 'boolean'; }\n    public toString() { return this.value ? 'true' : 'false'; }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if (!(other instanceof BoolValue))\n        {\n            return 1;\n        }\n\n        return boolCompareTo(this.value, other.value);\n    }\n}\n\nexport function boolCompareTo(left: boolean, right: boolean): CompareResult\n{\n    if (left === right)\n    {\n        return 0;\n    }\n    return left ? -1 : 1;\n}\n\nexport function isBoolValue(input: IValue | undefined): input is BoolValue\n{\n    return input instanceof BoolValue;\n}","import { CompareResult, IObjectValue, IValue } from \"./ivalues\";\nimport { NumberValue } from \"./numberValue\";\n\nconst keys: ReadonlyArray<string> = [ 'length' ];\nexport class StringValue implements IObjectValue\n{\n    public readonly value: string;\n\n    constructor (value: string)\n    {\n        this.value = value;\n    }\n\n    public typename() { return 'string'; }\n    public toString() { return this.value; }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if (!(other instanceof StringValue))\n        {\n            return 1;\n        }\n\n        const diff = this.value.localeCompare(other.value);\n        if (diff == 0) { return 0; }\n        if (diff < 0) { return -1; }\n        return 1;\n    }\n\n    public getIndex(index: number): number\n    {\n        if (index < 0)\n        {\n            return this.value.length + index;\n        }\n\n        return index;\n    }\n\n    public tryGetKey(key: string)\n    {\n        if (key === 'length')\n        {\n            return new NumberValue(this.value.length);\n        }\n\n        return undefined;\n    }\n\n    public objectKeys()\n    {\n        return keys;\n    }\n}\n\nexport function isStringValue(input: IValue | undefined): input is StringValue\n{\n    return input instanceof StringValue;\n}","import { isBoolValue } from \"./boolValue\";\nimport { CompareResult, IArrayValue, IObjectValue, IValue } from \"./ivalues\";\nimport { NumberValue, isNumberValue, numberCompareTo } from \"./numberValue\";\nimport { isStringValue } from \"./stringValue\";\n\nconst keys: ReadonlyArray<string> = [ \"length\" ];\n\nexport class ArrayValue implements IArrayValue, IObjectValue\n{\n    public static readonly Empty = new ArrayValue([], false);\n    public static readonly EmptyArgs = new ArrayValue([], true);\n\n    public readonly value: ReadonlyArray<IValue>;\n    public readonly isArgumentValue: boolean;\n\n    constructor (value: ReadonlyArray<IValue>, isArgumentValue: boolean = false)\n    {\n        this.value = value;\n        this.isArgumentValue = isArgumentValue;\n    }\n\n    public typename() { return this.isArgumentValue ? 'arguments' : 'array'; }\n    public toString()\n    {\n        let first = true;\n        let result = '(';\n        for (const item of this.value)\n        {\n            if (!first)\n            {\n                result += ' ';\n            }\n            first = false;\n            result += item.toString();\n        }\n        result += ')';\n        return result;\n    }\n    public arrayValues() { return this.value; }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if ((this as any) === other) { return 0; }\n        if (!(other instanceof ArrayValue)) { return 1; }\n\n        return arrayCompareTo(this, other);\n    }\n\n    public calcIndex(index: number): number\n    {\n        if (index < 0)\n        {\n            return this.value.length + index;\n        }\n\n        return index;\n    }\n\n    public tryGetIndex(index: number): IValue | undefined\n    {\n        return this.value[this.calcIndex(index)];\n    }\n\n    public getIndex(index: number): IValue\n    {\n        if (index < 0 || index >= this.value.length)\n        {\n            throw new Error('Out of index');\n        }\n\n        return this.value[index];\n    }\n\n    public getIndexCast<T>(index: number, guardCheck: (v: any) => v is T): T\n    {\n        const value = this.value[index];\n        if (guardCheck(value))\n        {\n            return value as T;\n        }\n\n        throw new Error(`Unable to get argument: [${index}] failed guard check`);\n    }\n\n    public getNumber(index: number)\n    {\n        return this.getIndexCast(index, isNumberValue).value;\n    }\n\n    public getString(index: number)\n    {\n        return this.getIndexCast(index, isStringValue).value;\n    }\n\n    public getBool(index: number)\n    {\n        return this.getIndexCast(index, isBoolValue).value;\n    }\n\n    public tryGetKey(key: string): IValue | undefined\n    {\n        if (key === 'length')\n        {\n            return new NumberValue(this.value.length);\n        }\n\n        return undefined;\n    }\n\n    public objectKeys()\n    {\n        return keys;\n    }\n}\n\nexport function arrayCompareTo(left: IArrayValue, right: IArrayValue): CompareResult\n{\n    const leftValue = left.arrayValues();\n    const rightValue = right.arrayValues();\n    const compareLength = numberCompareTo(leftValue.length, rightValue.length);\n    if (compareLength !== 0)\n    {\n        return compareLength;\n    }\n\n    for (let i = 0; i < leftValue.length; i++)\n    {\n        const compare = leftValue[i].compareTo(rightValue[i]);\n        if (compare !== 0)\n        {\n            return compare;\n        }\n    }\n\n    return 0;\n}\n\nexport function isArrayValue(input: IValue | undefined): input is ArrayValue\n{\n    return input !== undefined && input instanceof ArrayValue;\n}","import { VirtualMachine } from \"../virtualMachine\";\nimport { ArrayValue } from \"./arrayValue\";\n\nexport type CompareResult = -1 | 0 | 1;\nexport interface IValue\n{\n    readonly compareTo: (other: IValue) => CompareResult;\n    readonly toString: () => string;\n    readonly typename: () => string;\n}\n\nexport interface IObjectValue extends IValue\n{\n    readonly objectKeys: () => ReadonlyArray<string>;\n    readonly tryGetKey: (key: string) => IValue | undefined;\n}\n\nexport interface IArrayValue extends IValue\n{\n    readonly arrayValues: () => ReadonlyArray<IValue>;\n    readonly tryGetIndex: (index: number) => IValue | undefined;\n}\n\nexport interface IFunctionValue extends IValue\n{\n    readonly invoke: (vm: VirtualMachine, args: ArrayValue, pushToStackTrace: boolean) => void;\n}\n\nexport function isIArrayValue(input: IValue | undefined): input is IArrayValue\n{\n    return input !== undefined && typeof((input as any)['arrayValues']) === 'function';\n}\n\nexport function isIObjectValue(input: IValue | undefined): input is IObjectValue\n{\n    return input !== undefined && typeof((input as any)['objectKeys']) === 'function';\n}\n\nexport function isIFunctionValue(input: IValue | undefined): input is IFunctionValue\n{\n    return input !== undefined && typeof((input as any)['invoke']) === 'function';\n}","import { CompareResult, IValue } from \"./ivalues\";\n\nexport class NullValue implements IValue\n{\n    public static readonly Value = new NullValue();\n\n    public typename() { return 'null'; }\n    public toString() { return 'null'; }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if (!(other instanceof NullValue))\n        {\n            return 1;\n        }\n\n        return 0;\n    }\n}","import { CompareResult, IObjectValue, IValue } from \"./ivalues\";\nimport { numberCompareTo } from \"./numberValue\";\n\nexport interface ObjectValueMap\n{\n    readonly [key: string]: IValue\n}\n\nexport class ObjectValue implements IObjectValue\n{\n    public readonly value: ObjectValueMap;\n    public readonly keys: ReadonlyArray<string>;\n\n    constructor (value: ObjectValueMap)\n    {\n        this.value = value;\n        this.keys = Object.keys(value);\n    }\n\n    public typename() { return 'object'; }\n    public toString()\n    {\n        let first = true;\n        let result = '{';\n\n        for (const prop in this.value)\n        {\n            if (!first)\n            {\n                result += ' ';\n            }\n            first = false;\n\n            result += `\"${prop}\" `;\n            result += this.value[prop].toString();\n        }\n\n        result += '}';\n        return result;\n    }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if ((this as any) === other) { return 0; }\n        if (!(other instanceof ObjectValue)) { return 1; }\n\n        const compareLength = numberCompareTo(this.keys.length, other.keys.length);\n        if (compareLength !== 0)\n        {\n            return compareLength;\n        }\n\n        // Looping over the object is faster than looping over the keys\n        for (const prop in this.value)\n        {\n            const otherValue = other.value[prop];\n            if (otherValue === undefined)\n            {\n                return 1;\n            }\n\n            const compare = this.value[prop].compareTo(otherValue);\n            if (compare !== 0)\n            {\n                return compare;\n            }\n        }\n\n        return 0;\n    }\n\n    public tryGetKey(key: string)\n    {\n        return this.value[key];\n    }\n\n    public objectKeys()\n    {\n        return this.keys;\n    }\n}\n\nexport function isObjectValue(input: IValue | undefined): input is ObjectValue\n{\n    return input !== undefined && input instanceof ObjectValue;\n}","import { Scope, IReadOnlyScope } from \"../scope\";\nimport { ArrayValue, isArrayValue } from \"../values/arrayValue\";\nimport { BuiltinFunctionValue } from \"../values/builtinFunctionValue\";\nimport { IArrayValue, isIArrayValue, IValue } from \"../values/ivalues\";\nimport { NullValue } from \"../values/nullValue\";\nimport { ObjectValue, ObjectValueMap } from \"../values/objectValue\";\n\nexport const arrayScope: IReadOnlyScope = createArrayScope();\n\nexport function createArrayScope()\n{\n    const result = new Scope();\n\n    const arrayFunctions: ObjectValueMap =\n    {\n        join: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStack(new ArrayValue(args.value));\n        }, \"array.join\"),\n\n        length: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            vm.pushStackNumber(top.arrayValues().length);\n        }, \"array.length\"),\n\n        get: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const index = args.getNumber(1);\n            const result = get(top, index);\n            if (result !== undefined)\n            {\n                vm.pushStack(result);\n            }\n            else\n            {\n                vm.pushStack(NullValue.Value);\n            }\n        }, \"array.get\"),\n\n        set: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const index = args.getNumber(1);\n            const value = args.getIndex(2);\n            vm.pushStack(set(top, index, value));\n\n        }, \"array.set\"),\n\n        insert: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const index = args.getNumber(1);\n            const value = args.getIndex(2);\n            vm.pushStack(insert(top, index, value));\n        }, \"array.insert\"),\n\n        insertFlatten: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const index = args.getNumber(1);\n            const value = args.getIndexCast(2, isIArrayValue);\n            vm.pushStack(insertFlatten(top, index, value));\n        }, \"array.insertFlatten\"),\n\n        remove: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const value = args.getIndex(1);\n            vm.pushStack(remove(top, value));\n        }, \"array.remove\"),\n\n        removeAt: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const index = args.getNumber(1);\n            vm.pushStack(removeAt(top, index));\n        }, \"array.removeAt\"),\n\n        removeAll: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const value = args.getIndex(1);\n            vm.pushStack(removeAll(top, value));\n        }, \"array.removeAll\"),\n\n        contains: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const value = args.getIndex(1);\n            vm.pushStackBool(contains(top, value));\n        }, \"array.contains\"),\n\n        indexOf: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const value = args.getIndex(1);\n            vm.pushStackNumber(indexOf(top, value));\n        }, \"array.indexOf\"),\n\n        sublist: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isArrayValue);\n            const index = args.getNumber(1);\n            const length = args.getNumber(2);\n            vm.pushStack(sublist(top, index, length));\n        }, \"array.sublist\"),\n    }\n\n    result.define('array', new ObjectValue(arrayFunctions));\n\n    return result;\n}\n\nexport function set(target: ArrayValue, index: number, input: IValue): ArrayValue\n{\n    let result = [...target.value];\n    result[target.calcIndex(index)] = input;\n    return new ArrayValue(result);\n}\n\nexport function get(target: IArrayValue, index: number): IValue | undefined\n{\n    return target.tryGetIndex(index);\n}\n\nexport function insert(target: ArrayValue, index: number, input: IValue): ArrayValue\n{\n    index = target.calcIndex(index);\n    const result = [...target.value];\n    result.splice(index, 0, input);\n    return new ArrayValue(result);\n}\n\nexport function insertFlatten(target: ArrayValue, index: number, input: IArrayValue): ArrayValue\n{\n    index = target.calcIndex(index);\n    const result = [...target.value];\n    result.splice(index, 0, ...input.arrayValues());\n    return new ArrayValue(result);\n}\n\nexport function removeAt(target: ArrayValue, index: number): ArrayValue\n{\n    index = target.calcIndex(index);\n    const result = [...target.value];\n    result.splice(index, 1);\n    return new ArrayValue(result);\n}\n\nexport function remove(target: ArrayValue, value: IValue): ArrayValue\n{\n    const index = indexOf(target, value);\n    if (index < 0)\n    {\n        return target;\n    }\n\n    return removeAt(target, index);\n}\n\nexport function removeAll(target: ArrayValue, value: IValue): ArrayValue\n{\n    return new ArrayValue(target.value.filter(v => v.compareTo(value) !== 0));\n}\n\nexport function contains(target: IArrayValue, value: IValue): boolean\n{\n    return indexOf(target, value) >= 0;\n}\n\nexport function indexOf(target: IArrayValue, value: IValue): number\n{\n    return target.arrayValues().findIndex(v => v.compareTo(value) === 0);\n}\n\nexport function sublist(target: ArrayValue, index: number, length: number): ArrayValue\n{\n    index = target.calcIndex(index);\n    if (length < 0)\n    {\n        return new ArrayValue(target.value.slice(index));\n    }\n    return new ArrayValue(target.value.slice(index, index + length));\n}","import { CompareResult, IValue } from \"./ivalues\";\n\nexport class VariableValue implements IValue\n{\n    public readonly value: string;\n\n    public get isLabel() { return this.value.length > 0 && this.value[0] === ':'; }\n\n    constructor (value: string)\n    {\n        this.value = value;\n    }\n\n    public typename() { return 'variable'; }\n    public toString() { return this.value; }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if (!(other instanceof VariableValue))\n        {\n            return 1;\n        }\n\n        const diff = this.value.localeCompare(other.value);\n        if (diff == 0) { return 0; }\n        if (diff < 0) { return -1; }\n        return 1;\n    }\n}","import { IArrayValue, isIArrayValue, isIObjectValue, IValue } from \"./ivalues\";\nimport { NumberValue } from \"./numberValue\";\nimport { StringValue } from \"./stringValue\";\nimport { VariableValue } from \"./variableValue\";\n\nexport function getProperty(current: IValue, properties: IArrayValue): IValue | undefined\n{\n    const propValues = properties.arrayValues();\n    for (let i = 0; i < propValues.length; i++)\n    {\n        const index = parseIndex(propValues[i]);\n        if (index !== undefined && isIArrayValue(current))\n        {\n            const test = current.tryGetIndex(index);\n            if (test === undefined)\n            {\n                return undefined;\n            }\n            current = test;\n        }\n        else if (isIObjectValue(current))\n        {\n            const test = current.tryGetKey(propValues[i].toString());\n            if (test === undefined)\n            {\n                return undefined;\n            }\n            current = test;\n        }\n        else\n        {\n            return undefined;\n        }\n    }\n\n    return current;\n}\n\nexport function parseIndex(input: IValue): number | undefined\n{\n    if (input instanceof NumberValue)\n    {\n        return input.value;\n    }\n    else if (input instanceof StringValue || input instanceof VariableValue)\n    {\n        const index = parseInt(input.value);\n        return isFinite(index) ? index : undefined;\n    }\n\n    return undefined;\n}","import { CodeLine } from \"./virtualMachine\";\n\ntype CodeLines = ReadonlyArray<CodeLine>;\ntype Parameters = ReadonlyArray<string>;\ninterface Labels\n{\n    readonly [label: string]: number;\n}\n\nexport class VMFunction\n{\n    public static readonly Empty = new VMFunction([], [], {}, '');\n\n    public readonly code: CodeLines;\n    public readonly parameters: Parameters;\n    public readonly labels: Labels;\n    public readonly name: string;\n    public readonly hasName: boolean;\n\n    public get isEmpty()\n    {\n        return this.code.length == 0;\n    }\n\n    constructor (code: CodeLines, parameters: Parameters, labels: Labels, name: string)\n    {\n        this.code = code;\n        this.parameters = parameters;\n        this.labels = labels;\n        this.name = name.length > 0 ? name : 'anonymous';\n        this.hasName = name.length > 0;\n    }\n}","import { Scope, IReadOnlyScope } from \"./scope\";\nimport { Script } from \"./script\";\nimport { sublist } from \"./standardLibrary/standardArrayLibrary\";\nimport { ArrayValue } from \"./values/arrayValue\";\nimport { BoolValue, isBoolValue } from \"./values/boolValue\";\nimport { IFunctionValue, isIArrayValue, isIFunctionValue, IValue } from \"./values/ivalues\";\nimport { NumberValue, isNumberValue } from \"./values/numberValue\";\nimport { StringValue } from \"./values/stringValue\";\nimport { getProperty } from \"./values/valuePropertyAccess\";\nimport { VMFunction } from \"./vmFunction\";\n\nexport type Operator = 'unknown' |\n\n    // General\n    'push' | 'toArgument' |\n    'call' | 'callDirect' | 'return' |\n    'getProperty' | 'get' | 'set' | 'define' |\n    'jump' | 'jumpTrue' | 'jumpFalse' |\n\n    // Misc\n    'stringConcat' |\n\n    // Comparison\n    '>' | '>=' |\n    '==' | '!=' |\n    '<' | '<=' |\n\n    // Boolean\n    '!' | '&&' | '||' |\n\n    // Math\n    '+' | '-' | '*' | '/' |\n    '++' | '--' | 'unaryNegative'\n    ;\n\nexport interface CodeLine\n{\n    readonly operator: Operator;\n    readonly value?: IValue;\n}\n\nexport interface ScopeFrame\n{\n    readonly lineNumber: number;\n    readonly function: VMFunction;\n    readonly scope: Scope;\n}\n\nexport class VirtualMachine\n{\n    public builtinScope: IReadOnlyScope | undefined = undefined;\n\n    private _globalScope: Scope;\n    public get globalScope() { return this._globalScope; }\n    private _currentScope: Scope;\n\n    private _lineCounter: number = 0;\n    public get lineCounter() { return this._lineCounter; }\n\n    public running: boolean = false;\n    public paused: boolean = false;\n    public currentCode: VMFunction = VMFunction.Empty;\n\n    private _stack: IValue[] = [];\n    public get stack(): ReadonlyArray<IValue> { return this._stack; }\n\n    private _stackTrace: ScopeFrame[] = [];\n    public get stackTrace(): ReadonlyArray<ScopeFrame> { return this._stackTrace; }\n\n    private readonly _stackSize: number;\n\n    constructor (stackSize: number)\n    {\n        this._stackSize = stackSize;\n        this._globalScope = new Scope();\n        this._currentScope = this._globalScope;\n    }\n\n    public reset()\n    {\n        this._globalScope = new Scope();\n        this._currentScope = this._globalScope;\n        this._lineCounter = 0;\n        this._stack = [];\n        this._stackTrace = [];\n        this.running = false;\n        this.paused = false;\n    }\n\n    public changeToScript(script: Script)\n    {\n        this._lineCounter = 0;\n        this._stack = [];\n        this._stackTrace = [];\n\n        this.builtinScope = script.builtinScope;\n        this.currentCode = script.code;\n    }\n\n    public execute(script: Script)\n    {\n        this.changeToScript(script);\n\n        this.running = true;\n        this.paused = false;\n        while (this.running && !this.paused)\n        {\n            this.step();\n        }\n    }\n\n    public step()\n    {\n        if (this._lineCounter >= this.currentCode.code.length)\n        {\n            if (!this.tryCallReturn())\n            {\n                this.running = false;\n            }\n\n            return;\n        }\n\n        const codeLine = this.currentCode.code[this._lineCounter++];\n\n        switch (codeLine.operator)\n        {\n            default:\n                {\n                    throw new Error(`Unknown operator: ${codeLine.operator}`);\n                }\n\n            // General Operators\n            case 'push':\n                {\n                    if (codeLine.value !== undefined)\n                    {\n                        this.pushStack(codeLine.value);\n                    }\n                    else\n                    {\n                        throw new Error(`${this.getScopeLine()}: Push needs an input`);\n                    }\n                    break;\n                }\n            case 'toArgument':\n                {\n                    const top = codeLine.value ?? this.popStack();\n                    if (!(isIArrayValue(top)))\n                    {\n                        throw new Error(`${this.getScopeLine()}: Unable to convert argument value onto stack: ${top.toString()}`);\n                    }\n\n                    this.pushStack(new ArrayValue(top.arrayValues(), true));\n                    break;\n                }\n            case 'get':\n                {\n                    const key = codeLine.value ?? this.popStack();\n                    if (!(key instanceof StringValue))\n                    {\n                        throw new Error(`${this.getScopeLine()}: Unable to get, input must be a string not: ${key.toString()}`);\n                    }\n\n                    let foundValue = this._currentScope.get(key.value);\n                    if (foundValue !== undefined)\n                    {\n                        this.pushStack(foundValue);\n                        break;\n                    }\n                    else if (this.builtinScope !== undefined)\n                    {\n                        foundValue = this.builtinScope.get(key.value);\n                        if (foundValue !== undefined)\n                        {\n                            this.pushStack(foundValue);\n                            break;\n                        }\n                    }\n                    throw new Error(`${this.getScopeLine()}: Unable to get variable: ${key.toString()}`);\n                }\n            case 'getProperty':\n                {\n                    const key = codeLine.value ?? this.popStack();\n                    if (!isIArrayValue(key))\n                    {\n                        throw new Error(`${this.getScopeLine()}: Unable to get property, input needs to be an array: ${key.toString()}`)\n                    }\n\n                    const top = this.popStack();\n                    const found = getProperty(top, key);\n                    if (found !== undefined)\n                    {\n                        this.pushStack(found);\n                    }\n                    else\n                    {\n                        throw new Error(`${this.getScopeLine()}: Unable to get property: ${key.toString()}`);\n                    }\n                    break;\n                }\n            case 'define':\n                {\n                    const key = codeLine.value ?? this.popStack();\n                    const value = this.popStack();\n                    this._currentScope.define(key.toString(), value);\n                    break;\n                }\n            case 'set':\n                {\n                    const key = codeLine.value ?? this.popStack();\n                    const value = this.popStack();\n                    if (!this._currentScope.set(key.toString(), value))\n                    {\n                        throw new Error(`${this.getScopeLine()}: Unable to set variable that has not been defined: ${key.toString()} = ${value.toString()}`);\n                    }\n                    break;\n                }\n            case 'jumpFalse':\n                {\n                    const label = codeLine.value ?? this.popStack();\n                    const top = this.popStack();\n                    if (top.compareTo(BoolValue.False) === 0)\n                    {\n                        this.jump(label.toString());\n                    }\n                    break;\n                }\n            case 'jumpTrue':\n                {\n                    const label = codeLine.value ?? this.popStack();\n                    const top = this.popStack();\n                    if (top.compareTo(BoolValue.True) === 0)\n                    {\n                        this.jump(label.toString());\n                    }\n                    break;\n                }\n            case 'jump':\n                {\n                    const label = codeLine.value ?? this.popStack();\n                    this.jump(label.toString());\n                    break;\n                }\n            case 'return':\n                {\n                    this.callReturn();\n                    break;\n                }\n            case 'call':\n                {\n                    if (!(codeLine.value instanceof NumberValue))\n                    {\n                        throw new Error(`${this.getScopeLine()}: Call needs a num args code line input`);\n                    }\n\n                    const numArgs = codeLine.value;\n                    const top = this.popStack();\n                    if (isIFunctionValue(top))\n                    {\n                        this.callFunction(top, numArgs.value, true);\n                    }\n                    else\n                    {\n                        throw new Error(`${this.getScopeLine()}: Call needs a function to run: ${top.toString()}`);\n                    }\n                    break;\n                }\n            case 'callDirect':\n                {\n                    const funcCall = codeLine.value;\n                    if (funcCall == null || !isIArrayValue(funcCall) ||\n                        !isIFunctionValue(funcCall.tryGetIndex(0)) ||\n                        !(funcCall.tryGetIndex(1) instanceof NumberValue))\n                    {\n                        throw new Error(`${this.getScopeLine()}: Call direct needs an array of the function and num args code line input`);\n                    }\n\n                    this.callFunction(funcCall.tryGetIndex(0) as IFunctionValue, (funcCall.tryGetIndex(1) as NumberValue).value, true);\n                    break;\n                }\n\n            // Misc Operators\n            case 'stringConcat':\n                {\n                    if (!isNumberValue(codeLine.value))\n                    {\n                        throw new Error(`${this.getScopeLine()}: StringConcat operator needs the number of args to concat`);\n                    }\n\n                    const args = this.getArgs(codeLine.value.value);\n                    this.pushStackString(args.value.join(''));\n                    break;\n                }\n\n            // Math Operators\n            case '+':\n                {\n                    this.pushStackNumber(this.getNumArg(codeLine) + this.popStackNumber());\n                    break;\n                }\n            case '-':\n                {\n                    const right = this.getNumArg(codeLine);\n                    const left = this.popStackNumber();\n                    this.pushStackNumber(left - right);\n                    break;\n                }\n            case 'unaryNegative':\n                {\n                    this.pushStackNumber(-this.popStackNumber());\n                    break;\n                }\n            case '*':\n                {\n                    this.pushStackNumber(this.getNumArg(codeLine) * this.popStackNumber());\n                    break;\n                }\n            case '/':\n                {\n                    const right = this.getNumArg(codeLine);\n                    const left = this.popStackNumber();\n                    this.pushStackNumber(left / right);\n                    break;\n                }\n            case '++':\n                {\n                    if (codeLine.value == undefined)\n                    {\n                        throw new Error(`${this.getScopeLine()}: Inc operator needs code line variable`);\n                    }\n\n                    const key = codeLine.value.toString();\n                    const num = this._currentScope.getNumber(key);\n                    if (num === undefined)\n                    {\n                        throw new Error(`${this.getScopeLine()}: Inc operator could not find variable: ${key}`);\n                    }\n                    this._currentScope.set(key, new NumberValue(num + 1));\n                    break;\n                }\n            case '--':\n                {\n                    if (codeLine.value == undefined)\n                    {\n                        throw new Error(`${this.getScopeLine()}: Dec operator needs code line variable`);\n                    }\n\n                    const key = codeLine.value.toString();\n                    const num = this._currentScope.getNumber(key);\n                    if (num === undefined)\n                    {\n                        throw new Error(`${this.getScopeLine()}: Dec operator could not find variable: ${key}`);\n                    }\n                    this._currentScope.set(key, new NumberValue(num - 1));\n                    break;\n                }\n\n            // Comparison Operators\n            case '<':\n                {\n                    const right = codeLine.value ?? this.popStack();\n                    const left = this.popStack();\n                    this.pushStackBool(left.compareTo(right) < 0);\n                    break;\n                }\n            case '<=':\n                {\n                    const right = codeLine.value ?? this.popStack();\n                    const left = this.popStack();\n                    this.pushStackBool(left.compareTo(right) <= 0);\n                    break;\n                }\n            case '==':\n                {\n                    const right = codeLine.value ?? this.popStack();\n                    const left = this.popStack();\n                    this.pushStackBool(left.compareTo(right) == 0);\n                    break;\n                }\n            case '!=':\n                {\n                    const right = codeLine.value ?? this.popStack();\n                    const left = this.popStack();\n                    this.pushStackBool(left.compareTo(right) != 0);\n                    break;\n                }\n            case '>':\n                {\n                    const right = codeLine.value ?? this.popStack();\n                    const left = this.popStack();\n                    this.pushStackBool(left.compareTo(right) > 0);\n                    break;\n                }\n            case '>=':\n                {\n                    const right = codeLine.value ?? this.popStack();\n                    const left = this.popStack();\n                    this.pushStackBool(left.compareTo(right) >= 0);\n                    break;\n                }\n\n            // Boolean Operators\n            case '&&':\n                {\n                    this.pushStackBool(this.getBoolArg(codeLine) && this.popStackBool());\n                    break;\n                }\n            case '||':\n                {\n                    this.pushStackBool(this.getBoolArg(codeLine) || this.popStackBool());\n                    break;\n                }\n            case '!':\n                {\n                    this.pushStackBool(!this.popStackBool());\n                    break;\n                }\n        }\n    }\n\n    public tryCallReturn(): boolean\n    {\n        const scopeFrame = this._stackTrace.pop();\n        if (scopeFrame == undefined)\n        {\n            return false;\n        }\n\n        this._currentScope = scopeFrame.scope;\n        this._lineCounter = scopeFrame.lineNumber;\n        this.currentCode = scopeFrame.function;\n        return true;\n    }\n\n    public callReturn()\n    {\n        if (!this.tryCallReturn())\n        {\n            throw new Error(`${this.getScopeLine()}: Unable to return, call stack empty`);\n        }\n    }\n\n    public getArgs(numArgs: number): ArrayValue\n    {\n        if (numArgs === 0)\n        {\n            return ArrayValue.Empty;\n        }\n\n        let hasArguments = false;\n        const args: IValue[] = new Array(numArgs);\n        for (let i = 0; i < numArgs; i++)\n        {\n            const arg = this.popStack();\n            if (arg instanceof ArrayValue && arg.isArgumentValue)\n            {\n                hasArguments = true;\n            }\n            args[numArgs - i - 1] = arg;\n        }\n\n        if (hasArguments)\n        {\n            let combined: IValue[] = [];\n            for (const arg of args)\n            {\n                if (arg instanceof ArrayValue && arg.isArgumentValue)\n                {\n                    combined = combined.concat(arg.value);\n                }\n                else\n                {\n                    combined.push(arg);\n                }\n            }\n            return new ArrayValue(combined, true);\n        }\n        return new ArrayValue(args, true);\n    }\n\n    public getNumArg(codeLine: CodeLine): number\n    {\n        if (codeLine.value == null)\n        {\n            return this.popStackNumber();\n        }\n        if (isNumberValue(codeLine.value))\n        {\n            return codeLine.value.value;\n        }\n        throw new Error(`${this.getScopeLine()}: Error attempt to get number argument`);\n    }\n\n    public getBoolArg(codeLine: CodeLine): boolean\n    {\n        if (codeLine.value == null)\n        {\n            return this.popStackBool();\n        }\n        if (isBoolValue(codeLine.value))\n        {\n            return codeLine.value.value;\n        }\n        throw new Error(`${this.getScopeLine()}: Error attempt to get boolean argument`);\n    }\n\n    public jump(label: string)\n    {\n        const line = this.currentCode.labels[label];\n        if (line == null)\n        {\n            throw new Error(`${this.getScopeLine()}: Unable to jump to label: ${label}`);\n        }\n\n        this._lineCounter = line;\n    }\n\n    public callFunction(value: IFunctionValue, numArgs: number, pushToStackTrace: boolean)\n    {\n        const args = this.getArgs(numArgs);\n        value.invoke(this, args, pushToStackTrace);\n    }\n\n    public executeFunction(func: VMFunction, args: ArrayValue, pushToStackTrace = false)\n    {\n        if (pushToStackTrace)\n        {\n            this.pushCurrentToStackTrace();\n        }\n\n        this.currentCode = func;\n        this._currentScope = new Scope(this._currentScope);\n        this._lineCounter = 0;\n\n        const numCalledArgs = Math.min(args.value.length, func.parameters.length);\n        let i = 0;\n        for (; i < numCalledArgs; i++)\n        {\n            const argName = func.parameters[i];\n            if (argName.startsWith('...'))\n            {\n                args = sublist(args, i, -1);\n                this._currentScope.define(argName.substring(3), args);\n                i++;\n                break;\n            }\n            this._currentScope.define(argName, args.value[i]);\n        }\n\n        if (i < func.parameters.length)\n        {\n            const argName = func.parameters[i];\n            if (argName.startsWith('...'))\n            {\n                this._currentScope.define(argName.substring(3), ArrayValue.Empty);\n            }\n            else\n            {\n                throw new Error('Function called without enough arguments: ' + func.name);\n            }\n        }\n    }\n\n    public pushCurrentToStackTrace()\n    {\n        this.pushToStackTrace({\n            lineNumber: this._lineCounter,\n            scope: this._currentScope,\n            function: this.currentCode\n        });\n    }\n\n    public pushToStackTrace(scopeFrame: ScopeFrame)\n    {\n        if (this._stackTrace.length >= this._stackSize)\n        {\n            throw new Error(`${this.getScopeLine()}: Unable to push to stack trace, stack is full`);\n        }\n\n        this._stackTrace.push(scopeFrame);\n    }\n\n    public pushStack(value: IValue)\n    {\n        if (this._stack.length >= this._stackSize)\n        {\n            throw new Error(`${this.getScopeLine()}: Unable to push, stack full`);\n        }\n        this._stack.push(value);\n    }\n\n    public pushStackNumber(value: number)\n    {\n        this.pushStack(new NumberValue(value));\n    }\n\n    public pushStackString(value: string)\n    {\n        this.pushStack(new StringValue(value));\n    }\n\n    public pushStackBool(value: boolean)\n    {\n        this.pushStack(new BoolValue(value));\n    }\n\n    public popStack(): IValue\n    {\n        const result = this._stack.pop();\n        if (result === undefined)\n        {\n            throw new Error(`${this.getScopeLine()}: Popped empty stack`);\n        }\n        return result;\n    }\n\n    public popStackCast<T>(guardCheck: (v: any) => v is T): T\n    {\n        const top = this.popStack();\n        if (guardCheck(top))\n        {\n            return top as T;\n        }\n\n        throw new Error(`${this.getScopeLine()}: Pop stack cast error`);\n    }\n\n    public popStackNumber(): number\n    {\n        const result = this._stack.pop();\n        if (!isNumberValue(result))\n        {\n            throw new Error(`${this.getScopeLine()}: Pop stack error, not a number`);\n        }\n        return result.value;\n    }\n\n    public popStackBool(): boolean\n    {\n        const result = this._stack.pop();\n        if (!isBoolValue(result))\n        {\n            throw new Error(`${this.getScopeLine()}: Pop stack error, not a boolean`);\n        }\n        return result.value;\n    }\n\n    public peekStack(): IValue\n    {\n        if (this._stack.length === 0)\n        {\n            throw new Error(`${this.getScopeLine()}: Peek empty stack`);\n        }\n\n        return this._stack[this._stack.length - 1];\n    }\n\n    public createStackTrace(): string[]\n    {\n        const result = [ this.debugScopeLine(this.currentCode, this._lineCounter - 1) ];\n\n        for (let i = this.stackTrace.length - 1; i >= 0; i--)\n        {\n            const stackFrame = this._stackTrace[i];\n            result.push(this.debugScopeLine(stackFrame.function, stackFrame.lineNumber));\n        }\n\n        return result;\n    }\n\n    public debugScopeLine(func: VMFunction, line: number)\n    {\n        if (line >= func.code.length)\n        {\n            return `[${func.name}]:${line - 1}: end of code`;\n        }\n        if (line < 0)\n        {\n            return `[${func.name}]:${line - 1}: before start of code`;\n        }\n\n        const codeLine = func.code[line];\n        const codeLineInput = codeLine.value != null ? codeLine.value.toString() : '<empty>';\n        return `[${func.name}]:${line - 1}:${codeLine.operator}: [${codeLineInput}]`;\n    }\n\n    private getScopeLine()\n    {\n        return `${this.currentCode.name}:${this._lineCounter}`;\n    }\n}","import { ArrayValue } from \"./values/arrayValue\";\nimport { BoolValue } from \"./values/boolValue\";\nimport { IValue } from \"./values/ivalues\";\nimport { NullValue } from \"./values/nullValue\";\nimport { NumberValue } from \"./values/numberValue\";\nimport { ObjectValue } from \"./values/objectValue\";\nimport { StringValue } from \"./values/stringValue\";\nimport { VariableValue } from \"./values/variableValue\";\n\nexport function tokenize(input: string)\n{\n    let inQuote = \"\\0\";\n    let escaped = false;\n    let inComment = false;\n    let accumulator = \"\";\n    let index = 0;\n    const result: string[] = [];\n\n    while (index < input.length)\n    {\n        const ch = input.charAt(index++);\n        if (inComment)\n        {\n            if (ch === '\\n' || ch === '\\r')\n            {\n                inComment = false;\n            }\n            continue;\n        }\n\n        if (inQuote != '\\0')\n        {\n            if (escaped)\n            {\n                switch (ch)\n                {\n                    case '\"':\n                    case '\\'':\n                    case '\\\\':\n                        {\n                            accumulator += ch;\n                            break;\n                        }\n                    case 't':\n                        {\n                            accumulator += '\\t';\n                            break;\n                        }\n                    case 'r':\n                        {\n                            accumulator += '\\r';\n                            break;\n                        }\n                    case 'n':\n                        {\n                            accumulator += '\\n';\n                            break;\n                        }\n                }\n                escaped = false;\n                continue;\n            }\n            else if (ch == '\\\\')\n            {\n                escaped = true;\n                continue;\n            }\n\n            accumulator += ch;\n            if (ch == inQuote)\n            {\n                result.push(accumulator);\n                accumulator = \"\";\n                inQuote = '\\0';\n            }\n        }\n        else\n        {\n            switch (ch)\n            {\n                case ';':\n                    {\n                        inComment = true;\n                        break;\n                    }\n\n                case '\"':\n                case '\\'':\n                    {\n                        inQuote = ch;\n                        accumulator += ch;\n                        break;\n                    }\n\n                case '(':\n                case ')':\n                case '{':\n                case '}':\n                    {\n                        if (accumulator.length > 0)\n                        {\n                            result.push(accumulator);\n                            accumulator = \"\";\n                        }\n                        result.push(ch);\n                        break;\n                    }\n\n                case ' ':\n                case '\\t':\n                case '\\n':\n                case '\\r':\n                    {\n                        if (accumulator.length > 0)\n                        {\n                            result.push(accumulator);\n                            accumulator = \"\";\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        accumulator += ch;\n                        break;\n                    }\n            }\n        }\n    }\n\n    return result;\n}\n\nexport function readAllTokens(tokens: string[]): ArrayValue\n{\n    const result: IValue[] = [];\n\n    while (tokens.length > 0)\n    {\n        result.push(readFromTokens(tokens));\n    }\n\n    return new ArrayValue(result);\n}\n\nexport function readFromTokens(tokens: string[]): IValue\n{\n    if (tokens.length === 0)\n    {\n        throw new Error('Unexpected end of tokens');\n    }\n\n    const token = popFront(tokens);\n    if (token === '(')\n    {\n        const list: IValue[] = [];\n        while (tokens[0] !== ')')\n        {\n            list.push(readFromTokens(tokens));\n        }\n        popFront(tokens);\n        return new ArrayValue(list);\n    }\n    else if (token === ')')\n    {\n        throw new Error('Unexpected )');\n    }\n    else if (token === '{')\n    {\n        const map: { [key: string]: IValue } = {};\n        while (tokens[0] !== '}')\n        {\n            const key = readFromTokens(tokens).toString();\n            const value = readFromTokens(tokens);\n            map[key] = value;\n        }\n        popFront(tokens);\n        return new ObjectValue(map);\n    }\n    else if (token === '}')\n    {\n        throw new Error('Unexpected }');\n    }\n    else\n    {\n        return atom(token);\n    }\n}\n\nfunction atom(input: string): IValue\n{\n    const parsedNumber = parseFloat(input);\n    if (!isNaN(parsedNumber))\n    {\n        return new NumberValue(parsedNumber);\n    }\n    if (input === 'true')\n    {\n        return BoolValue.True;\n    }\n    if (input === 'false')\n    {\n        return BoolValue.False;\n    }\n    if (input === 'null')\n    {\n        return NullValue.Value;\n    }\n\n    const first = input[0];\n    const last = input[input.length - 1];\n    if ((first === '\"' && last === '\"') ||\n        (first === \"'\" && last === \"'\"))\n    {\n        return new StringValue(input.substring(1, input.length - 1));\n    }\n\n    return new VariableValue(input);\n}\n\nfunction popFront<T>(input: T[])\n{\n    if (input.length === 0)\n    {\n        throw new Error('Unable to pop empty list');\n    }\n\n    const result = input[0];\n    input.splice(0, 1);\n    return result;\n}","import { Scope, IReadOnlyScope } from \"./scope\";\nimport { VMFunction } from \"./vmFunction\";\n\nexport class Script\n{\n    public static readonly Empty = new Script(Scope.Empty, VMFunction.Empty);\n\n    public readonly builtinScope: IReadOnlyScope;\n    public readonly code: VMFunction;\n\n    constructor (builtinScope: IReadOnlyScope, code: VMFunction)\n    {\n        this.builtinScope = builtinScope;\n        this.code = code;\n    }\n}","import { VirtualMachine } from \"../virtualMachine\";\nimport { VMFunction } from \"../vmFunction\";\nimport { ArrayValue } from \"./arrayValue\";\nimport { CompareResult, IFunctionValue, IValue } from \"./ivalues\";\n\nexport class FunctionValue implements IFunctionValue\n{\n    public readonly value: VMFunction;\n\n    constructor(value: VMFunction)\n    {\n        this.value = value;\n    }\n\n    public typename() { return 'function' ;}\n    public toString() { return 'function:' + this.value.name; }\n\n    public compareTo(other: IValue): CompareResult\n    {\n        if ((this as any) === other) { return 0; }\n        if (!(other instanceof FunctionValue)) { return 1; }\n\n        return this.value === other.value ? 0 : 1;\n    }\n\n    public invoke(vm: VirtualMachine, args: ArrayValue, pushToStackTrace: boolean)\n    {\n        vm.executeFunction(this.value, args, pushToStackTrace);\n    }\n}","import { readAllTokens, tokenize } from \"./parser\";\nimport { Scope } from \"./scope\";\nimport { Script } from \"./script\";\nimport { ArrayValue } from \"./values/arrayValue\";\nimport { FunctionValue } from \"./values/functionValue\";\nimport { IArrayValue, IFunctionValue, isIArrayValue, isIFunctionValue, IValue } from \"./values/ivalues\";\nimport { NumberValue, isNumberValue } from \"./values/numberValue\";\nimport { StringValue } from \"./values/stringValue\";\nimport { getProperty } from \"./values/valuePropertyAccess\";\nimport { VariableValue } from \"./values/variableValue\";\nimport { CodeLine, Operator } from \"./virtualMachine\";\nimport { VMFunction } from \"./vmFunction\";\n\ninterface TempCodeLine\n{\n    readonly label?: string;\n    readonly operator?: Operator;\n    readonly value?: IValue;\n}\n\ninterface LoopLabels\n{\n    readonly start: string;\n    readonly end: string;\n}\n\ninterface PropertyRequestInfo\n{\n    readonly isPropertyRequest: boolean;\n    readonly parentKey: string;\n    readonly property: ArrayValue;\n}\n\nconst FunctionKeyword = 'function';\nconst LoopKeyword = 'loop';\nconst ContinueKeyword = 'continue';\nconst BreakKeyword = 'break';\nconst IfKeyword = 'if';\nconst UnlessKeyword = 'unless';\nconst SetKeyword = 'set';\nconst DefineKeyword = 'define';\nconst JumpKeyword = 'jump';\nconst ReturnKeyword = 'return';\n\nfunction codeLine(operator: Operator, value?: IValue): TempCodeLine\n{\n    return { operator, value };\n}\n\nfunction labelLine(label: string): TempCodeLine\n{\n    return { label };\n}\n\nexport class VirtualMachineAssembler\n{\n    public builtinScope: Scope = new Scope();\n\n    private labelCount: number = 0;\n    private loopStack: LoopLabels[] = [];\n    private keywordParsingStack: string[] = [];\n\n    public parseFromText(input: string)\n    {\n        const tokens = tokenize(input);\n        const parsed = readAllTokens(tokens);\n\n        const code = this.parseGlobalFunction(parsed);\n        const scriptScope = new Scope();\n        scriptScope.combineScope(this.builtinScope);\n\n        return new Script(scriptScope, code);\n    }\n\n    public parse(input: IValue): TempCodeLine[]\n    {\n        if (input instanceof ArrayValue)\n        {\n            if (input.value.length === 0)\n            {\n                return [];\n            }\n\n            const first = input.value[0];\n            // If the first item in an array is a variable we assume that it is a function call or a label\n            if (first instanceof VariableValue)\n            {\n                const firstString = first.toString();\n                if (first.isLabel)\n                {\n                    return [ labelLine(firstString) ];\n                }\n\n                // Check for keywords\n                const keywordParse = this.parseKeyword(firstString, input);\n                if (keywordParse.length > 0)\n                {\n                    return keywordParse;\n                }\n\n                this.keywordParsingStack.push('func-call');\n\n                // Handle general opcode or function call.\n                let result = input.value.slice(1).map(v => this.parse(v)).flat(1);\n                result = result.concat(this.optimiseCallSymbolValue(first.value, input.value.length - 1));\n\n                this.keywordParsingStack.pop();\n\n                return result;\n            }\n\n            // Any array that doesn't start with a variable we assume it's a data array.\n        }\n        else if (input instanceof VariableValue)\n        {\n            if (!input.isLabel)\n            {\n                return this.optimiseGetSymbolValue(input.value);\n            }\n        }\n\n        return [ codeLine('push', input) ];\n    }\n\n    public parseDefineSet(input: ArrayValue, isDefine: boolean)\n    {\n        const opCode: Operator = isDefine ? 'define' : 'set';\n        // Parse the last value as the definable/set-able value.\n        const result = this.parse(input.value[input.value.length - 1]);\n\n        // Loop over all the middle inputs as the values to set.\n        // Multiple variables can be set when a function returns multiple results.\n        for (let i = input.value.length - 2; i >= 1; i--)\n        {\n            result.push(codeLine(opCode, input.value[i]));\n        }\n        return result;\n    }\n\n    public parseLoop(input: ArrayValue)\n    {\n        if (input.value.length < 3)\n        {\n            throw new Error('Loop input has too few arguments');\n        }\n\n        const loopLabelNum = this.labelCount++;\n        const labelStart = `:LoopStart${loopLabelNum}`;\n        const labelEnd = `:LoopEnd${loopLabelNum}`;\n\n        this.loopStack.push({ start: labelStart, end: labelEnd });\n\n        const comparisonCall = input.value[1];\n        let result = [ labelLine(labelStart), ...this.parse(comparisonCall) ];\n        result.push(codeLine('jumpFalse', new StringValue(labelEnd)));\n        for (let i = 2; i < input.value.length; i++)\n        {\n            result = result.concat(this.parse(input.value[i]));\n        }\n\n        result.push(codeLine('jump', new StringValue(labelStart)));\n        result.push(labelLine(labelEnd));\n\n        this.loopStack.pop();\n\n        return result;\n    }\n\n    public parseCond(input: ArrayValue, isIfStatement: boolean)\n    {\n        if (input.value.length < 3)\n        {\n            throw new Error('Condition input has too few inputs');\n        }\n        if (input.value.length > 4)\n        {\n            throw new Error('Condition input has too many inputs!');\n        }\n\n        const ifLabelNum = this.labelCount++;\n        const labelElse = `:CondElse${ifLabelNum}`;\n        const labelEnd = `:CondEnd${ifLabelNum}`;\n\n        const hasElseCall = input.value.length === 4;\n        const jumpOperator = isIfStatement ? 'jumpFalse' : 'jumpTrue';\n\n        const comparisonCall = input.value[1];\n        const firstBlock = input.value[2] as ArrayValue;\n\n        let result = this.parse(comparisonCall);\n\n        if (hasElseCall)\n        {\n            // Jump to else if the condition doesn't match\n            result.push(codeLine(jumpOperator, new StringValue(labelElse)));\n\n            // First block of code\n            result = result.concat(this.parseFlatten(firstBlock));\n            // Jump after the condition, skipping second block of code.\n            result.push(codeLine('jump', new StringValue(labelEnd)));\n\n            // Jump target for else\n            result.push(labelLine(labelElse));\n\n            // Second 'else' block of code\n            const secondBlock = input.value[3] as ArrayValue;\n            result = result.concat(this.parseFlatten(secondBlock));\n        }\n        else\n        {\n            // We only have one block, so jump to the end of the block if the condition doesn't match\n            result.push(codeLine(jumpOperator, new StringValue(labelEnd)));\n\n            result = result.concat(this.parseFlatten(firstBlock));\n        }\n\n        result.push(labelLine(labelEnd));\n\n        return result;\n    }\n\n    public parseFlatten(input: ArrayValue)\n    {\n        if (input.value.every(isIArrayValue))\n        {\n            return input.value.map(v => this.parse(v)).flat(1);\n        }\n\n        return this.parse(input);\n    }\n\n    public parseLoopJump(keyword: string, jumpToStart: boolean)\n    {\n        if (this.loopStack.length === 0)\n        {\n            throw new Error(`Unexpected ${keyword} outside of loop`);\n        }\n\n        const loopLabel = this.loopStack[this.loopStack.length - 1];\n        return [codeLine('jump', new StringValue(jumpToStart ? loopLabel.start : loopLabel.end))];\n    }\n\n    public parseFunction(input: ArrayValue)\n    {\n        let name = '';\n        let offset = 0;\n        if (input.value[1] instanceof VariableValue || input.value[1] instanceof StringValue)\n        {\n            name = input.value[1].toString();\n            offset = 1;\n        }\n\n        if (!isIArrayValue(input.value[1 + offset]))\n        {\n            throw new Error('Function needs parameter array');\n        }\n\n        const parameters = (input.value[1 + offset] as IArrayValue).arrayValues().map(e => e.toString());\n        const tempCodeLines = input.value.slice(2 + offset).map(v => this.parse(v)).flat(1);\n\n        return this.processTempFunction(parameters, tempCodeLines, name);\n    }\n\n    public parseGlobalFunction(input: ArrayValue)\n    {\n        const tempCodeLines = input.value.map(v => this.parse(v)).flat(1);\n        return this.processTempFunction([], tempCodeLines, 'global');\n    }\n\n    public processTempFunction(parameters: string[], tempCodeLines: TempCodeLine[], name: string) : VMFunction\n    {\n        const labels: { [label: string]: number } = {}\n        const code: CodeLine[] = [];\n\n        for (const tempLine of tempCodeLines)\n        {\n            if (tempLine.label !== undefined && tempLine.label != '')\n            {\n                labels[tempLine.label] = code.length;\n            }\n            else if (tempLine.operator !== undefined)\n            {\n                code.push({ operator: tempLine.operator, value: tempLine.value });\n            }\n        }\n\n        return new VMFunction(code, parameters, labels, name);\n    }\n\n    public parseChangeVariable(input: IValue, changeFunc: IFunctionValue)\n    {\n        const varName = new StringValue(input.toString());\n        return [\n            codeLine('get', varName),\n            codeLine('callDirect', new ArrayValue([changeFunc, new NumberValue(1)])),\n            codeLine('set', varName)\n        ];\n    }\n\n    public parseJump(input: ArrayValue)\n    {\n        let parse = this.parse(input.value[1]);\n        if (parse.length === 1 && parse[0].operator === 'push' && parse[0].value !== undefined)\n        {\n            return [codeLine('jump', parse[0].value)];\n        }\n        parse.push(codeLine('push'));\n        return parse;\n    }\n\n    public parseReturn(input: ArrayValue)\n    {\n        const result = input.value.slice(1).map(v => this.parse(v)).flat(1);\n        result.push(codeLine('return'));\n        return result;\n    }\n\n    public parseFunctionKeyword(arrayValue: ArrayValue): TempCodeLine[]\n    {\n        const func = this.parseFunction(arrayValue);\n        const funcValue = new FunctionValue(func);\n        const result = [codeLine('push', funcValue)];\n\n        const currentKeyword = this.keywordParsingStack.length > 1 ? this.keywordParsingStack[this.keywordParsingStack.length - 1] : FunctionKeyword;\n        if (func.hasName && currentKeyword === FunctionKeyword)\n        {\n            result.push(codeLine('define', new StringValue(func.name)));\n        }\n\n        return result;\n    }\n\n    public parseNegative(input: ArrayValue): TempCodeLine[]\n    {\n        if (input.value.length >= 3)\n        {\n            return this.parseOperator('-', input);\n        }\n        else if (input.value.length === 2)\n        {\n            if (isNumberValue(input.value[1]))\n            {\n                return [codeLine('push', new NumberValue(-input.value[1].value))];\n            }\n\n            const result = this.parse(input.value[1]);\n            result.push(codeLine('unaryNegative'));\n            return result;\n        }\n        else\n        {\n            throw new Error('Negative/Sub operator expects at least 1 input');\n        }\n    }\n\n    public parseOnePushInput(opCode: Operator, input: ArrayValue): TempCodeLine[]\n    {\n        if (input.value.length < 2)\n        {\n            throw new Error(`Expecting at least 1 input for: ${opCode}`);\n        }\n\n        let result: TempCodeLine[] = [];\n        for (let i = 1; i < input.value.length; i++)\n        {\n            result = result.concat(this.parse(input.value[i]));\n            result.push(codeLine(opCode));\n        }\n        return result;\n    }\n\n    public parseOperator(opCode: Operator, input: ArrayValue): TempCodeLine[]\n    {\n        if (input.value.length < 3)\n        {\n            throw new Error(`Expecting at least 3 inputs for: ${opCode}`);\n        }\n\n        let result = this.parse(input.value[1]);\n        for (let i = 2; i < input.value.length; i++)\n        {\n            const item = input.value[i];\n            if (isNumberValue(item))\n            {\n                result.push(codeLine(opCode, item));\n            }\n            else\n            {\n                result = result.concat(this.parse(item));\n                result.push(codeLine(opCode));\n            }\n        }\n\n        return result;\n    }\n\n    public parseOneVariableUpdate(opCode: Operator, input: ArrayValue): TempCodeLine[]\n    {\n        if (input.value.length < 2)\n        {\n            throw new Error(`Expecting at least 1 input for: ${opCode}`);\n        }\n\n        let result: TempCodeLine[] = [];\n        for (let i = 1; i < input.value.length; i++)\n        {\n            const varName = new StringValue(input.value[i].toString());\n            result.push(codeLine(opCode, varName));\n        }\n        return result;\n    }\n\n    public parseStringConcat(input: ArrayValue): TempCodeLine[]\n    {\n        const result = input.value.slice(1).map(v => this.parse(v)).flat(1);\n        result.push(codeLine('stringConcat', new NumberValue(input.value.length - 1)));\n        return result;\n    }\n\n    public transformAssignmentOperator(arrayValue: ArrayValue): TempCodeLine[]\n    {\n        let opCode = arrayValue.value[0].toString();\n        opCode = opCode.substring(0, opCode.length - 1);\n\n        const varName = arrayValue.value[1].toString();\n        const newCode = [...arrayValue.value];\n        newCode[0] = new VariableValue(opCode);\n\n        const wrappedCode = [\n            new VariableValue('set'),\n            new VariableValue(varName),\n            new ArrayValue(newCode)\n        ];\n\n        return this.parse(new ArrayValue(wrappedCode));\n    }\n\n    public parseKeyword(input: string, arrayValue: ArrayValue): TempCodeLine[]\n    {\n        let result: TempCodeLine[] | null = null;\n\n        this.keywordParsingStack.push(input);\n        switch (input)\n        {\n            // General Operators\n            case FunctionKeyword: result = this.parseFunctionKeyword(arrayValue); break;\n            case ContinueKeyword: result = this.parseLoopJump(ContinueKeyword, true); break;\n            case BreakKeyword: result = this.parseLoopJump(BreakKeyword, false); break;\n            case SetKeyword: result = this.parseDefineSet(arrayValue, false); break;\n            case DefineKeyword: result = this.parseDefineSet(arrayValue, true); break;\n            case LoopKeyword: result = this.parseLoop(arrayValue); break;\n            case IfKeyword: result = this.parseCond(arrayValue, true); break;\n            case UnlessKeyword: result = this.parseCond(arrayValue, false); break;\n            case JumpKeyword: result = this.parseJump(arrayValue); break;\n            case ReturnKeyword: result = this.parseReturn(arrayValue); break;\n\n            // Math Operators\n            case '+':\n            case '*':\n            case '/': result = this.parseOperator(input as Operator, arrayValue); break;\n            case '-': result = this.parseNegative(arrayValue); break;\n\n            case '++':\n            case '--': result = this.parseOneVariableUpdate(input as Operator, arrayValue); break;\n\n            // Comparison Operators\n            case '<':\n            case '<=':\n            case '==':\n            case '!=':\n            case '>':\n            case '>=': result = this.parseOperator(input as Operator, arrayValue); break;\n\n            // Boolean Operators\n            case '&&':\n            case '||': result = this.parseOperator(input as Operator, arrayValue); break;\n            case '!':  result = this.parseOnePushInput('!', arrayValue); break;\n\n            // Misc Operators\n            case '$': result = this.parseStringConcat(arrayValue); break;\n\n            // Conjoined Operators\n            case '+=':\n            case '-=':\n            case '*=':\n            case '/=':\n            case '&&=':\n            case '||=':\n            case '$=': result = this.transformAssignmentOperator(arrayValue); break;\n        }\n\n        this.keywordParsingStack.pop();\n\n        return result != null ? result : [];\n    }\n\n    private optimiseCallSymbolValue(input: string, numArgs: number): TempCodeLine[]\n    {\n        const numArgsValue = new NumberValue(numArgs);\n        const propertyRequestInfo = VirtualMachineAssembler.isGetPropertyRequest(input);\n\n        // Check if we know about the parent object? (eg: string.length, the parent is the string object)\n        const foundParent = this.builtinScope.get(propertyRequestInfo.parentKey);\n        if (foundParent !== undefined)\n        {\n            // If the get is for a property? (eg: string.length, length is the property)\n            let foundProperty: IValue | undefined = undefined;\n            if (propertyRequestInfo.isPropertyRequest && (foundProperty = getProperty(foundParent, propertyRequestInfo.property)) !== undefined)\n            {\n                if (isIFunctionValue(foundProperty))\n                {\n                    // If we found the property then we're done and we can just push that known value onto the stack.\n                    const callValue = new ArrayValue([foundProperty, numArgsValue]);\n                    return [codeLine('callDirect', callValue)];\n                }\n\n                throw new Error(`Attempting to call a value that is not a function: ${input} = ${foundProperty.toString()}`);\n            }\n            else if (!propertyRequestInfo.isPropertyRequest)\n            {\n                // This was not a property request but we found the parent so just push onto the stack.\n                if (isIFunctionValue(foundParent))\n                {\n                    const callValue = new ArrayValue([foundParent, numArgsValue]);\n                    return [codeLine('callDirect', callValue)];\n                }\n\n                throw new Error(`Attempting to call a value that is not a function: ${input} = ${foundParent.toString()}`);\n            }\n        }\n\n        // Could not find the parent right now, so look for the parent at runtime.\n        const result: TempCodeLine[] = [codeLine('get', new StringValue(propertyRequestInfo.parentKey))];\n\n        // If this was also a property check also look up the property at runtime.\n        if (propertyRequestInfo.isPropertyRequest)\n        {\n            result.push(codeLine('getProperty', propertyRequestInfo.property));\n        }\n\n        result.push(codeLine('call', numArgsValue));\n        return result;\n    }\n\n    private optimiseGetSymbolValue(input: string): TempCodeLine[]\n    {\n        let isArgumentUnpack = false;\n        if (input.startsWith('...'))\n        {\n            isArgumentUnpack = true;\n            input = input.substring(3);\n        }\n\n        const result: TempCodeLine[] = [];\n\n        const propertyRequestInfo = VirtualMachineAssembler.isGetPropertyRequest(input);\n        const foundParent = this.builtinScope.get(propertyRequestInfo.parentKey);\n        if (foundParent !== undefined)\n        {\n            if (propertyRequestInfo.isPropertyRequest)\n            {\n                const foundProperty = getProperty(foundParent, propertyRequestInfo.property);\n                if (foundProperty !== undefined)\n                {\n                    result.push(codeLine('push', foundProperty));\n                }\n                else\n                {\n                    result.push(codeLine('push', foundParent));\n                    result.push(codeLine('getProperty', propertyRequestInfo.property));\n                }\n            }\n            else if (!propertyRequestInfo.isPropertyRequest)\n            {\n                result.push(codeLine('push', foundParent));\n            }\n        }\n        else\n        {\n            result.push(codeLine('get', new StringValue(propertyRequestInfo.parentKey)));\n\n            if (propertyRequestInfo.isPropertyRequest)\n            {\n                result.push(codeLine('getProperty', propertyRequestInfo.property));\n            }\n        }\n\n        if (isArgumentUnpack)\n        {\n            result.push(codeLine('toArgument', undefined));\n        }\n\n        return result;\n    }\n\n    private static isGetPropertyRequest(input: string): PropertyRequestInfo\n    {\n        if (input.includes('.'))\n        {\n            const split = input.split('.');\n            const parentKey = split[0];\n            const property = new ArrayValue(split.slice(1).map(c => new VariableValue(c)));\n            return {\n                isPropertyRequest: true, parentKey, property\n            }\n        }\n\n        return {\n            isPropertyRequest: false, parentKey: input, property: ArrayValue.Empty\n        }\n    }\n}","import { Scope, IReadOnlyScope } from \"../scope\";\nimport { BuiltinFunctionValue } from \"../values/builtinFunctionValue\";\nimport { NumberValue, isNumberValue } from \"../values/numberValue\";\nimport { ObjectValue, ObjectValueMap } from \"../values/objectValue\";\n\nconst degToRad = Math.PI / 180.0;\n\nexport const mathScope: IReadOnlyScope = createMathScope();\n\nexport function createMathScope()\n{\n    const result = new Scope();\n\n    const mathFunctions: ObjectValueMap =\n    {\n        E: new NumberValue(Math.E),\n        PI: new NumberValue(Math.PI),\n        DegToRad: new NumberValue(degToRad),\n\n        sin: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.sin(args.getNumber(0)));\n        }, \"math.sin\"),\n        cos: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.cos(args.getNumber(0)));\n        }, \"math.cos\"),\n        tan: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.tan(args.getNumber(0)));\n        }, \"math.tan\"),\n        exp: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.exp(args.getNumber(0)));\n        }, \"math.exp\"),\n        ceil: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.ceil(args.getNumber(0)));\n        }, \"math.ceil\"),\n        floor: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.floor(args.getNumber(0)));\n        }, \"math.floor\"),\n        round: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.round(args.getNumber(0)));\n        }, \"math.round\"),\n        isFinite: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackBool(Number.isFinite(args.getNumber(0)));\n        }, \"math.isFinite\"),\n        isNaN: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackBool(isNaN(args.getNumber(0)));\n        }, \"math.isNaN\"),\n        parse: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndex(0);\n            if (isNumberValue(top))\n            {\n                vm.pushStack(top);\n            }\n            else\n            {\n                vm.pushStackNumber(parseFloat(top.toString()));\n            }\n        }, \"math.parse\"),\n        log: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.log(args.getNumber(0)));\n        }, \"math.log\"),\n        abs: new BuiltinFunctionValue((vm, args) =>\n        {\n            vm.pushStackNumber(Math.abs(args.getNumber(0)));\n        }, \"math.abs\"),\n        max: new BuiltinFunctionValue((vm, args) =>\n        {\n            let max = args.value[0];\n            for (let i = 1; i < args.value.length; i++)\n            {\n                const next = args.value[i];\n                if (next.compareTo(max) > 0)\n                {\n                    max = next;\n                }\n            }\n            vm.pushStack(max);\n        }, \"math.max\"),\n        min: new BuiltinFunctionValue((vm, args) =>\n        {\n            let min = args.value[0];\n            for (let i = 1; i < args.value.length; i++)\n            {\n                const next = args.value[i];\n                if (next.compareTo(min) < 0)\n                {\n                    min = next;\n                }\n            }\n            vm.pushStack(min);\n        }, \"math.min\"),\n        sum: new BuiltinFunctionValue((vm, args) =>\n        {\n            let result = 0.0;\n            for (let i = 0; i < args.value.length; i++)\n            {\n                const item = args.value[i];\n                if (isNumberValue(item))\n                {\n                    result += item.value;\n                }\n                else\n                {\n                    throw new Error('Addition operator expects all numbers');\n                }\n            }\n            vm.pushStackNumber(result);\n        }, \"math.sum\")\n    };\n\n    result.define('math', new ObjectValue(mathFunctions));\n\n    return result;\n}\n","import { Scope, IReadOnlyScope } from \"../scope\";\nimport { BuiltinFunctionValue } from \"../values/builtinFunctionValue\";\nimport { ObjectValue, ObjectValueMap } from \"../values/objectValue\";\nimport { StringValue, isStringValue } from \"../values/stringValue\";\n\nexport const stringScope: IReadOnlyScope = createStringScope();\n\nexport function createStringScope()\n{\n    const result = new Scope();\n\n    const stringFunctions: ObjectValueMap =\n    {\n        join: new BuiltinFunctionValue((vm, args) =>\n        {\n            if (args.value.length < 2)\n            {\n                throw new Error('Not enough arguments for string join');\n            }\n\n            const separator = args.value[0];\n            const result = args.value.slice(1).join(separator.toString());\n            vm.pushStackString(result);\n        }, \"string.join\"),\n\n        length: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getString(0);\n            vm.pushStackNumber(top.length);\n        }, \"string.length\"),\n\n        get: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isStringValue);\n            const index = args.getNumber(1);\n            vm.pushStackString(top.value[top.getIndex(index)]);\n        }, \"string.get\"),\n\n        set: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isStringValue);\n            const index = args.getNumber(1);\n            const value = args.getIndex(2).toString();\n            vm.pushStack(set(top, index, value));\n        }, \"string.set\"),\n\n        insert: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isStringValue);\n            const index = args.getNumber(1);\n            const value = args.getIndex(2).toString();\n            vm.pushStack(insert(top, index, value));\n        }, \"string.insert\"),\n\n        substring: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isStringValue);\n            const index = args.getNumber(1);\n            const length = args.getNumber(2);\n            vm.pushStack(substring(top, index, length));\n        }, \"string.substring\"),\n\n        removeAt: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isStringValue);\n            const index = args.getNumber(1);\n            vm.pushStack(removeAt(top, index));\n        }, \"string.removeAt\"),\n\n        removeAll: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isStringValue);\n            const values = args.getIndex(1).toString();\n            vm.pushStack(removeAll(top, values));\n        }, \"string.removeAll\")\n    }\n\n    result.define('string', new ObjectValue(stringFunctions));\n\n    return result;\n}\n\nexport function set(input: StringValue, index: number, value: string): StringValue\n{\n    index = input.getIndex(index);\n    return new StringValue(`${input.value.substring(0, index)}${value}${input.value.substring(index + 1)}`);\n}\n\nexport function insert(input: StringValue, index: number, value: string): StringValue\n{\n    index = input.getIndex(index);\n    return new StringValue(`${input.value.substring(0, index)}${value}${input.value.substring(index)}`);\n}\n\nexport function removeAt(input: StringValue, index: number): StringValue\n{\n    index = input.getIndex(index);\n    return new StringValue(`${input.value.substring(0, index)}${input.value.substring(index + 1)}`);\n}\n\nexport function removeAll(input: StringValue, values: string): StringValue\n{\n    return new StringValue(input.value.replace(values, ''));\n}\n\nexport function substring(input: StringValue, index: number, length: number): StringValue\n{\n    index = input.getIndex(index);\n    return new StringValue(input.value.substring(index, index + length));\n}\n","import { Scope, IReadOnlyScope } from \"../scope\";\nimport { ArrayValue } from \"../values/arrayValue\";\nimport { BuiltinFunctionValue } from \"../values/builtinFunctionValue\";\nimport { IValue } from \"../values/ivalues\";\nimport { NullValue } from \"../values/nullValue\";\nimport { ObjectValue, isObjectValue, ObjectValueMap } from \"../values/objectValue\";\nimport { StringValue } from \"../values/stringValue\";\n\nexport const objectScope: IReadOnlyScope = createObjectScope();\n\nexport type Editable<T> =\n{\n    -readonly [P in keyof T]: T[P];\n};\n\nexport function createObjectScope()\n{\n    const result = new Scope();\n\n    const objectFunctions: ObjectValueMap =\n    {\n        set: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isObjectValue);\n            const key = args.getString(1);\n            const value = args.getIndex(2);\n            vm.pushStack(set(top, key, value));\n        }, \"object.set\"),\n\n        get: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isObjectValue);\n            const key = args.getString(1);\n            const found = get(top, key);\n            if (found !== undefined)\n            {\n                vm.pushStack(found);\n            }\n            else\n            {\n                vm.pushStack(NullValue.Value);\n            }\n        }, \"object.get\"),\n\n        removeKey: new BuiltinFunctionValue((vm, args) =>\n        {\n            const obj = args.getIndexCast(0, isObjectValue);\n            const key = args.getString(1);\n            vm.pushStack(removeKey(obj, key));\n        }, \"object.removeKey\"),\n\n        removeValues: new BuiltinFunctionValue((vm, args) =>\n        {\n            const obj = args.getIndexCast(0, isObjectValue);\n            const values = args.getIndex(1);\n            vm.pushStack(removeValues(obj, values));\n        }, \"object.removeValues\"),\n\n        keys: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isObjectValue);\n            vm.pushStack(keys(top));\n        }, \"object.keys\"),\n\n        values: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isObjectValue);\n            vm.pushStack(values(top));\n        }, \"object.values\"),\n\n        length: new BuiltinFunctionValue((vm, args) =>\n        {\n            const top = args.getIndexCast(0, isObjectValue);\n            vm.pushStackNumber(length(top));\n        }, \"object.length\")\n    }\n\n    result.define('object', new ObjectValue(objectFunctions));\n\n    return result;\n}\n\nexport function set(target: ObjectValue, key: string, value: IValue)\n{\n    return new ObjectValue({ ...target.value, [key]: value });\n}\n\nexport function get(target: ObjectValue, key: string) : IValue | undefined\n{\n    const result = target.value[key];\n    return result != null ? result : undefined;\n}\n\nexport function keys(target: ObjectValue): ArrayValue\n{\n    return new ArrayValue(target.keys.map(s => new StringValue(s)));\n}\n\nexport function removeKey(target: ObjectValue, key: string): ObjectValue\n{\n    if (!target.value.hasOwnProperty(key))\n    {\n        return target;\n    }\n\n    const result = { ...target.value };\n    delete result[key];\n    return new ObjectValue(result);\n}\n\nexport function removeValues(target: ObjectValue, values: IValue): ObjectValue\n{\n    const result: Editable<ObjectValueMap> = {};\n    for (const key in target.value)\n    {\n        if (target.value[key].compareTo(values) !== 0)\n        {\n            result[key] = target.value[key];\n        }\n    }\n\n    return new ObjectValue(result);\n}\n\nexport function values(target: ObjectValue): ArrayValue\n{\n    return new ArrayValue(Object.values(target.value));\n}\n\nexport function length(target: ObjectValue)\n{\n    return target.keys.length;\n}","import { Scope, IReadOnlyScope } from \"../scope\";\n\nexport const miscScope: IReadOnlyScope = createMiscScope();\n\nexport function createMiscScope()\n{\n    const result = new Scope();\n\n    result.defineFunc('toString', (vm, args) =>\n    {\n        vm.pushStackString(args.getIndex(0).toString());\n    });\n\n    result.defineFunc('typeof', (vm, args) =>\n    {\n        vm.pushStackString(args.getIndex(0).typename());\n    });\n\n    result.defineFunc('compareTo', (vm, args) =>\n    {\n        vm.pushStackNumber(args.getIndex(0).compareTo(args.getIndex(1)));\n    });\n\n    result.defineFunc('print', (vm, args) =>\n    {\n        console.log(args.value.map(c => c.toString()).join(''));\n    });\n\n    return result;\n}","import { Scope } from \"../scope\";\nimport { mathScope } from \"./standardMathLibrary\";\nimport { stringScope } from \"./standardStringLibrary\";\nimport { arrayScope } from \"./standardArrayLibrary\";\nimport { objectScope } from \"./standardObjectLibrary\";\nimport { miscScope } from \"./standardMiscLibrary\";\n\nexport { mathScope } from \"./standardMathLibrary\";\nexport { stringScope } from \"./standardStringLibrary\";\nexport { arrayScope } from \"./standardArrayLibrary\";\nexport { objectScope } from \"./standardObjectLibrary\";\nexport { miscScope } from \"./standardMiscLibrary\";\n\nexport enum LibraryType {\n    math = 1 << 0,\n    string = 1 << 1,\n    array = 1 << 2,\n    object = 1 << 3,\n    misc = 1 << 4,\n    all = (1 << 5) - 1\n}\n\nexport function addToScope(scope: Scope, libraries: LibraryType)\n{\n    if (libraries & LibraryType.math)\n    {\n        scope.combineScope(mathScope);\n    }\n    if (libraries & LibraryType.string)\n    {\n        scope.combineScope(stringScope);\n    }\n    if (libraries & LibraryType.array)\n    {\n        scope.combineScope(arrayScope);\n    }\n    if (libraries & LibraryType.object)\n    {\n        scope.combineScope(objectScope);\n    }\n    if (libraries & LibraryType.misc)\n    {\n        scope.combineScope(miscScope);\n    }\n}","import { getTextFor } from \"./common\";\n\nimport { VirtualMachine } from 'lysithea-vm/src/virtualMachine';\nimport { VirtualMachineAssembler } from 'lysithea-vm/src/assembler';\nimport { addToScope, LibraryType } from 'lysithea-vm/src/standardLibrary';\n\nfunction runStdLib(codeId: string)\n{\n    const codeContext = getTextFor(codeId);\n    if (codeContext === false)\n    {\n        return;\n    }\n\n    const assembler = new VirtualMachineAssembler();\n    addToScope(assembler.builtinScope, LibraryType.all);\n\n    assembler.builtinScope.defineFunc(\"print\", (vm, args) =>\n    {\n        const text = args.value.map(c => c.toString()).join('');\n        console.log(text);\n        codeContext.output.innerHTML += text + '<br/>';\n    });\n\n    const script = assembler.parseFromText(codeContext.text as string);\n    const vm = new VirtualMachine(16);\n    vm.execute(script);\n}\n\n(globalThis as any).runStdLib = runStdLib;","import { Scope } from \"lysithea-vm/src/scope\";\nimport { isArrayValue } from \"lysithea-vm/src/values/arrayValue\";\nimport { BuiltinFunctionValue } from \"lysithea-vm/src/values/builtinFunctionValue\";\nimport { IArrayValue } from \"lysithea-vm/src/values/ivalues\";\nimport { ObjectValue, ObjectValueMap } from \"lysithea-vm/src/values/objectValue\";\n\nfunction createScope()\n{\n    const result = new Scope();\n\n    const randomFunctions: ObjectValueMap =\n    {\n        pick: new BuiltinFunctionValue((vm, args) =>\n        {\n            let input: IArrayValue = args;\n            if (args.value.length === 1)\n            {\n                const list = args.getIndexCast(0, isArrayValue);\n                if (list)\n                {\n                    input = list;\n                }\n            }\n\n            const index = Math.floor(Math.random() * input.arrayValues().length);\n            vm.pushStack(input.arrayValues()[index]);\n        }, \"random.pick\")\n    }\n\n    result.define(\"random\", new ObjectValue(randomFunctions));\n\n    return result;\n}\n\nexport const randomScope = createScope();","import { getTextFor } from './common';\nimport { randomScope } from './randomLibrary';\n\nimport { VirtualMachine } from 'lysithea-vm/src/virtualMachine';\nimport { VirtualMachineAssembler } from 'lysithea-vm/src/assembler';\nimport { addToScope, LibraryType } from 'lysithea-vm/src/standardLibrary';\nimport { Scope } from 'lysithea-vm/src/scope';\n\nconst pageSetupScope = new Scope();\npageSetupScope.defineFunc(\"setBackground\", (vm, args) =>\n{\n    document.body.setAttribute('background', args.getString(0));\n});\npageSetupScope.defineFunc(\"setTheme\", (vm, args) =>\n{\n    document.body.setAttribute('theme', args.getString(0));\n});\n\nfunction runPageSetup()\n{\n    const codeContext = getTextFor('codePageSetup');\n    if (codeContext === false)\n    {\n        return;\n    }\n\n    const assembler = new VirtualMachineAssembler();\n    addToScope(assembler.builtinScope, LibraryType.all);\n    assembler.builtinScope.combineScope(pageSetupScope);\n    assembler.builtinScope.combineScope(randomScope);\n    assembler.builtinScope.defineFunc(\"print\", (vm, args) =>\n    {\n        const text = args.value.map(c => c.toString()).join('');\n        console.log(text);\n        codeContext.output.innerHTML += text + '<br/>';\n    });\n\n    const script = assembler.parseFromText(codeContext.text as string);\n    const vm = new VirtualMachine(16);\n    vm.execute(script);\n}\n\n(globalThis as any).runPageSetup = runPageSetup;","import { getTextFor } from './common';\n\nimport { VirtualMachine } from 'lysithea-vm/src/virtualMachine';\nimport { VirtualMachineAssembler } from 'lysithea-vm/src/assembler';\nimport { Scope } from 'lysithea-vm/src/scope';\n\nconst perfTestScope = new Scope();\nperfTestScope.defineFunc(\"rand\", (vm, args) =>\n{\n    vm.pushStackNumber(Math.random());\n});\n\nfunction runPerfTest()\n{\n    const codeContext = getTextFor('codePerfTest');\n    if (codeContext === false)\n    {\n        return;\n    }\n\n    const assembler = new VirtualMachineAssembler();\n    assembler.builtinScope.combineScope(perfTestScope);\n    assembler.builtinScope.defineFunc(\"print\", (vm, args) =>\n    {\n        const text = args.value.map(c => c.toString()).join('');\n        console.log(text);\n        codeContext.output.innerHTML += text + '<br/>';\n    });\n\n    const script = assembler.parseFromText(codeContext.text as string);\n    const vm = new VirtualMachine(16);\n\n    const before = Date.now();\n    vm.execute(script);\n    const after = Date.now();\n    codeContext.output.innerHTML += `Time taken: ${after - before}ms <br/>`;\n}\n\n(globalThis as any).runPerfTest = runPerfTest;"],"names":["$b7a1dabe93a79a87$export$bfc0113c3d732dd9","codeId","textEl","document","getElementById","output","alert","text","value","innerHTML","$77f6e60782b5b0aa$export$1e722e6f052edcbe","constructor","name","this","typename","toString","compareTo","other","invoke","vm","args","pushToStackTrace","$f3b9685e182d46b6$export$782358ed72c6211e","$f3b9685e182d46b6$export$b45f8e7f10f2c276","left","right","diff","Math","abs","$f3b9685e182d46b6$export$3ff5e9927c3257c6","input","$b7f1d34eb997560a$export$775b6bb06e53a214","static","undefined","_values","values","parent","_parent","combineScope","prop","define","key","defineFunc","set","hasOwnProperty","get","result","getNumber","$e7b03793c68ee57c$export$2fbe858e1700680c","$e7b03793c68ee57c$export$4858e7fe56d1249c","$b64960917a24807c$var$keys","$b64960917a24807c$export$d1f904342138ad76","localeCompare","getIndex","index","length","tryGetKey","objectKeys","$b64960917a24807c$export$6a1b4a9bf3282","$77cf41f6df259127$var$keys","$77cf41f6df259127$export$f06b0ce79fd44095","isArgumentValue","first","item","arrayValues","leftValue","rightValue","compareLength","i","compare","$77cf41f6df259127$export$f94b21f5e5401c62","calcIndex","tryGetIndex","Error","getIndexCast","guardCheck","getString","getBool","$77cf41f6df259127$export$19e12b0055ed689b","$a3781c84863de672$export$ab6a8e1f77eb196f","$a3781c84863de672$export$b3ad70d109c18202","$434d0940529acbf0$export$2b9002e549dccbbd","$8d96d2322e5c0263$export$7b660e20faa35e02","keys","Object","otherValue","$8d96d2322e5c0263$export$2e3322e72933e7ed","$2ebd49591fca3c99$export$3644508f69c42aab","arrayFunctions","join","pushStack","top","pushStackNumber","target","$2ebd49591fca3c99$export$3988ae62b71be9a3","Value","$2ebd49591fca3c99$export$adaa4cf7ef1b65be","insert","splice","$2ebd49591fca3c99$export$21a5ca8aa77d35ff","insertFlatten","$2ebd49591fca3c99$export$a76049923398d9c8","remove","$2ebd49591fca3c99$export$305f7d4e9d4624f2","$2ebd49591fca3c99$export$aa72b1a59562dee2","$2ebd49591fca3c99$export$cd7f480d6b8286c3","removeAt","removeAll","filter","v","$2ebd49591fca3c99$export$1cfc7aad5cb1833b","contains","pushStackBool","$2ebd49591fca3c99$export$2344b14b097df817","indexOf","sublist","$2ebd49591fca3c99$export$ac867dd9ed1f115b","$2ebd49591fca3c99$export$14c7b40ce54a5e95","findIndex","slice","$f3e19550b3729ed6$export$542385c6217fc721","isLabel","$5d4d89de81a8f1be$export$63ef76b19cf4a753","current","properties","propValues","$5d4d89de81a8f1be$export$bc79a594c704037f","test","test1","parseInt","isFinite","$d3766c86ad4e55f4$export$9fec95916becdf1f","isEmpty","code","parameters","labels","hasName","$349486dd41701ef2$export$d4057312c1c9b9a4","builtinScope","globalScope","_globalScope","_lineCounter","lineCounter","running","paused","currentCode","Empty","_stack","stack","_stackTrace","stackTrace","stackSize","_stackSize","_currentScope","reset","changeToScript","script","execute","step","tryCallReturn","codeLine","operator","getScopeLine","popStack","foundValue","key1","found","key2","key3","value1","label","False","jump","label1","True","label2","callReturn","numArgs","top4","callFunction","funcCall","getArgs","pushStackString","getNumArg","popStackNumber","right1","left1","key4","num","key5","num1","right2","left2","right3","left3","right4","left4","right5","left5","right6","left6","right7","left7","getBoolArg","popStackBool","scopeFrame","pop","scope","lineNumber","function","hasArguments","Array","arg","combined","arg1","concat","push","line","executeFunction","func","pushCurrentToStackTrace","numCalledArgs","min","argName","startsWith","substring","argName1","popStackCast","peekStack","createStackTrace","debugScopeLine","stackFrame","codeLineInput","$db2909e681dd2064$export$660b2ee2d4fb4eff","inQuote","escaped","inComment","accumulator","ch","charAt","$db2909e681dd2064$export$da129e3333579ed1","tokens","$db2909e681dd2064$export$6111c2d9796130cf","token","$db2909e681dd2064$var$popFront","list","map","parsedNumber","parseFloat","isNaN","last","$db2909e681dd2064$var$atom","$9e5ab6532e389ed3$export$2f8b47a141e57afc","$fcff175a7f1c72bd$export$41ff2ce55dc61f8f","$c45a15fbfac44487$var$codeLine","$c45a15fbfac44487$var$labelLine","$c45a15fbfac44487$export$fddbdd05ff5f3039","labelCount","loopStack","keywordParsingStack","parseFromText","parsed","parseGlobalFunction","scriptScope","parse","firstString","keywordParse","parseKeyword","flat","optimiseCallSymbolValue","optimiseGetSymbolValue","parseDefineSet","isDefine","opCode","parseLoop","loopLabelNum","labelStart","labelEnd","start","end","comparisonCall","parseCond","isIfStatement","ifLabelNum","labelElse","hasElseCall","jumpOperator","firstBlock","parseFlatten","secondBlock","every","parseLoopJump","keyword","jumpToStart","loopLabel","parseFunction","offset","e","tempCodeLines","processTempFunction","tempLine","parseChangeVariable","changeFunc","varName","parseJump","parseReturn","parseFunctionKeyword","arrayValue","currentKeyword","parseNegative","parseOperator","parseOnePushInput","parseOneVariableUpdate","parseStringConcat","transformAssignmentOperator","newCode","wrappedCode","numArgsValue","propertyRequestInfo","isGetPropertyRequest","foundParent","parentKey","foundProperty","isPropertyRequest","property","isArgumentUnpack","includes","split","c","$6717fdf8dd1a7e7e$var$degToRad","PI","$6717fdf8dd1a7e7e$export$5f98872cc189b7ac","mathFunctions","E","DegToRad","sin","cos","tan","exp","ceil","floor","round","Number","log","max","next","sum","$6717fdf8dd1a7e7e$export$761a6c3831f78758","$cb41d7854598406e$export$73259254879392f","stringFunctions","separator","$cb41d7854598406e$export$adaa4cf7ef1b65be","$cb41d7854598406e$export$21a5ca8aa77d35ff","$cb41d7854598406e$export$662d3818631fba36","$cb41d7854598406e$export$aa72b1a59562dee2","replace","$cb41d7854598406e$export$1cfc7aad5cb1833b","$cb41d7854598406e$export$c3b09398ddd87864","$324049063da1c740$export$38c6809f78b9bc5b","objectFunctions","$324049063da1c740$export$adaa4cf7ef1b65be","$324049063da1c740$export$3988ae62b71be9a3","removeKey","obj","$324049063da1c740$export$95148fb8c42fcae8","removeValues","$324049063da1c740$export$1552d7838e1e4499","s","$324049063da1c740$export$8c4d4ce2785a9d6","$4bd67b7d47ed4c29$export$4691ec1931ef4efc","console","$4bd67b7d47ed4c29$export$5b4fed8d4e23e9a","$4f0000ffa44cb8e6$export$7a934bdf726ba376","LibraryType","$4f0000ffa44cb8e6$export$3379e794862e641b","libraries","math","string","array","object","misc","globalThis","runStdLib","codeContext","assembler","all","$928a6ca5f1a9cff8$export$80256126ab298581","randomFunctions","pick","random","$928a6ca5f1a9cff8$var$createScope","$1ce97a4f4e2995c2$var$pageSetupScope","body","setAttribute","runPageSetup","$a2b89264df7b7d5f$var$perfTestScope","runPerfTest","before","Date","now","after"],"version":3,"file":"index.215d08d6.js.map"}