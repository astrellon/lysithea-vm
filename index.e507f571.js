class e{constructor(e,t){this.value=e,this.name=t}typename(){return"builtin-function"}toString(){return`builtin-function:${this.name}`}compareTo(t){return t instanceof e&&this.value===t.value?0:1}invoke(e,t,n){this.value(e,t)}}class t{constructor(e){this.value=e}typename(){return"number"}toString(){return this.value.toString()}compareTo(e){return e instanceof t?n(this.value,e.value):1}}function n(e,t){const n=e-t;return Math.abs(n)<1e-4?0:n<0?-1:1}function r(e){return e instanceof t}class s{static Empty=new s(void 0);_values={};get values(){return this._values}constructor(e){this._parent=e}combineScope(e){for(const t in e.values)this.define(t,e.values[t])}define(e,t){this._values[e]=t}defineFunc(t,n,r=null){this._values[t]=new e(n,r??t)}set(e,t){return this._values.hasOwnProperty(e)?(this._values[e]=t,!0):!!this._parent&&this._parent.set(e,t)}get(e){const t=this._values[e];return null!=t?t:void 0!==this._parent?this._parent.get(e):void 0}getNumber(e){const t=this.get(e);if(r(t))return t.value}}class a{static True=new a(!0);static False=new a(!1);constructor(e){this.value=e}typename(){return"boolean"}toString(){return this.value?"true":"false"}compareTo(e){return e instanceof a?(t=this.value,n=e.value,t===n?0:t?-1:1):1;var t,n}}function o(e){return e instanceof a}const i=["length"];class u{constructor(e){this.value=e}typename(){return"string"}toString(){return this.value}compareTo(e){if(!(e instanceof u))return 1;const t=this.value.localeCompare(e.value);return 0==t?0:t<0?-1:1}getIndex(e){return e<0?this.value.length+e:e}tryGetKey(e){if("length"===e)return new t(this.value.length)}objectKeys(){return i}}function c(e){return e instanceof u}const l=["length"];class h{static Empty=new h([],!1);static EmptyArgs=new h([],!0);constructor(e,t=!1){this.value=e,this.isArgumentValue=t}typename(){return this.isArgumentValue?"arguments":"array"}toString(){let e=!0,t="(";for(const n of this.value)e||(t+=" "),e=!1,t+=n.toString();return t+=")",t}arrayValues(){return this.value}compareTo(e){return this===e?0:e instanceof h?function(e,t){const r=e.arrayValues(),s=t.arrayValues(),a=n(r.length,s.length);if(0!==a)return a;for(let e=0;e<r.length;e++){const t=r[e].compareTo(s[e]);if(0!==t)return t}return 0}(this,e):1}calcIndex(e){return e<0?this.value.length+e:e}tryGetIndex(e){return this.value[this.calcIndex(e)]}getIndex(e){if(e<0||e>=this.value.length)throw new Error("Out of index");return this.value[e]}getIndexCast(e,t){const n=this.value[e];if(t(n))return n;throw new Error(`Unable to get argument: [${e}] failed guard check`)}getNumber(e){return this.getIndexCast(e,r).value}getString(e){return this.getIndexCast(e,c).value}getBool(e){return this.getIndexCast(e,o).value}tryGetKey(e){if("length"===e)return new t(this.value.length)}objectKeys(){return l}}function p(e){return void 0!==e&&e instanceof h}function g(e){return void 0!==e&&"function"==typeof e.arrayValues}function f(e){return void 0!==e&&"function"==typeof e.invoke}class S{static Value=new S;typename(){return"null"}toString(){return"null"}compareTo(e){return e instanceof S?0:1}}class v{constructor(e){this.value=e,this.keys=Object.keys(e)}typename(){return"object"}toString(){let e=!0,t="{";for(const n in this.value)e||(t+=" "),e=!1,t+=`"${n}" `,t+=this.value[n].toString();return t+="}",t}compareTo(e){if(this===e)return 0;if(!(e instanceof v))return 1;const t=n(this.keys.length,e.keys.length);if(0!==t)return t;for(const t in this.value){const n=e.value[t];if(void 0===n)return 1;const r=this.value[t].compareTo(n);if(0!==r)return r}return 0}tryGetKey(e){return this.value[e]}objectKeys(){return this.keys}}function m(e){return void 0!==e&&e instanceof v}const k=function(){const t=new s,n={join:new e(((e,t)=>{e.pushStack(new h(t.value))}),"array.join"),length:new e(((e,t)=>{const n=t.getIndexCast(0,p);e.pushStackNumber(n.arrayValues().length)}),"array.length"),get:new e(((e,t)=>{const n=function(e,t){return e.tryGetIndex(t)}(t.getIndexCast(0,p),t.getNumber(1));void 0!==n?e.pushStack(n):e.pushStack(S.Value)}),"array.get"),set:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getNumber(1),s=t.getIndex(2);e.pushStack(function(e,t,n){let r=[...e.value];return r[e.calcIndex(t)]=n,new h(r)}(n,r,s))}),"array.set"),insert:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getNumber(1),s=t.getIndex(2);e.pushStack(function(e,t,n){t=e.calcIndex(t);const r=[...e.value];return r.splice(t,0,n),new h(r)}(n,r,s))}),"array.insert"),insertFlatten:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getNumber(1),s=t.getIndexCast(2,g);e.pushStack(function(e,t,n){t=e.calcIndex(t);const r=[...e.value];return r.splice(t,0,...n.arrayValues()),new h(r)}(n,r,s))}),"array.insertFlatten"),remove:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getIndex(1);e.pushStack(function(e,t){const n=b(e,t);return n<0?e:w(e,n)}(n,r))}),"array.remove"),removeAt:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getNumber(1);e.pushStack(w(n,r))}),"array.removeAt"),removeAll:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getIndex(1);e.pushStack(function(e,t){return new h(e.value.filter((e=>0!==e.compareTo(t))))}(n,r))}),"array.removeAll"),contains:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getIndex(1);e.pushStackBool(function(e,t){return b(e,t)>=0}(n,r))}),"array.contains"),indexOf:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getIndex(1);e.pushStackNumber(b(n,r))}),"array.indexOf"),sublist:new e(((e,t)=>{const n=t.getIndexCast(0,p),r=t.getNumber(1),s=t.getNumber(2);e.pushStack(d(n,r,s))}),"array.sublist")};return t.define("array",new v(n)),t}();function w(e,t){t=e.calcIndex(t);const n=[...e.value];return n.splice(t,1),new h(n)}function b(e,t){return e.arrayValues().findIndex((e=>0===e.compareTo(t)))}function d(e,t,n){return t=e.calcIndex(t),new h(n<0?e.value.slice(t):e.value.slice(t,t+n))}class y{get isLabel(){return this.value.length>0&&":"===this.value[0]}constructor(e){this.value=e}typename(){return"variable"}toString(){return this.value}compareTo(e){if(!(e instanceof y))return 1;const t=this.value.localeCompare(e.value);return 0==t?0:t<0?-1:1}}function x(e,t){const n=t.arrayValues();for(let t=0;t<n.length;t++){const s=N(n[t]);if(void 0!==s&&g(e)){const t=e.tryGetIndex(s);if(void 0===t)return;e=t}else{if(void 0===(r=e)||"function"!=typeof r.objectKeys)return;{const r=e.tryGetKey(n[t].toString());if(void 0===r)return;e=r}}}var r;return e}function N(e){if(e instanceof t)return e.value;if(e instanceof u||e instanceof y){const t=parseInt(e.value);return isFinite(t)?t:void 0}}class C{static Empty=new C([],[],{},"");get isEmpty(){return 0==this.code.length}constructor(e,t,n,r){this.code=e,this.parameters=t,this.labels=n,this.name=r.length>0?r:"anonymous",this.hasName=r.length>0}}class I{builtinScope=void 0;get globalScope(){return this._globalScope}_lineCounter=0;get lineCounter(){return this._lineCounter}running=!1;paused=!1;currentCode=C.Empty;_stack=[];get stack(){return this._stack}_stackTrace=[];get stackTrace(){return this._stackTrace}constructor(e){this._stackSize=e,this._globalScope=new s,this._currentScope=this._globalScope}reset(){this._globalScope=new s,this._currentScope=this._globalScope,this._lineCounter=0,this._stack=[],this._stackTrace=[],this.running=!1,this.paused=!1}changeToScript(e){this._lineCounter=0,this._stack=[],this._stackTrace=[],this.builtinScope=e.builtinScope,this.currentCode=e.code}execute(e){for(this.changeToScript(e),this.running=!0,this.paused=!1;this.running&&!this.paused;)this.step()}step(){if(this._lineCounter>=this.currentCode.code.length)return void(this.tryCallReturn()||(this.running=!1));const e=this.currentCode.code[this._lineCounter++];switch(e.operator){default:throw new Error(`Unknown operator: ${e.operator}`);case"push":if(void 0===e.value)throw new Error(`${this.getScopeLine()}: Push needs an input`);this.pushStack(e.value);break;case"toArgument":{const t=e.value??this.popStack();if(!g(t))throw new Error(`${this.getScopeLine()}: Unable to convert argument value onto stack: ${t.toString()}`);this.pushStack(new h(t.arrayValues(),!0));break}case"get":{const t=e.value??this.popStack();if(!(t instanceof u))throw new Error(`${this.getScopeLine()}: Unable to get, input must be a string not: ${t.toString()}`);let n=this._currentScope.get(t.value);if(void 0!==n){this.pushStack(n);break}if(void 0!==this.builtinScope&&(n=this.builtinScope.get(t.value),void 0!==n)){this.pushStack(n);break}throw new Error(`${this.getScopeLine()}: Unable to get variable: ${t.toString()}`)}case"getProperty":{const t=e.value??this.popStack();if(!g(t))throw new Error(`${this.getScopeLine()}: Unable to get property, input needs to be an array: ${t.toString()}`);const n=x(this.popStack(),t);if(void 0===n)throw new Error(`${this.getScopeLine()}: Unable to get property: ${t.toString()}`);this.pushStack(n);break}case"define":{const t=e.value??this.popStack(),n=this.popStack();this._currentScope.define(t.toString(),n);break}case"set":{const t=e.value??this.popStack(),n=this.popStack();if(!this._currentScope.set(t.toString(),n))throw new Error(`${this.getScopeLine()}: Unable to set variable that has not been defined: ${t.toString()} = ${n.toString()}`);break}case"jumpFalse":{const t=e.value??this.popStack();0===this.popStack().compareTo(a.False)&&this.jump(t.toString());break}case"jumpTrue":{const t=e.value??this.popStack();0===this.popStack().compareTo(a.True)&&this.jump(t.toString());break}case"jump":{const t=e.value??this.popStack();this.jump(t.toString());break}case"return":this.callReturn();break;case"call":{if(!(e.value instanceof t))throw new Error(`${this.getScopeLine()}: Call needs a num args code line input`);const n=e.value,r=this.popStack();if(!f(r))throw new Error(`${this.getScopeLine()}: Call needs a function to run: ${r.toString()}`);this.callFunction(r,n.value,!0);break}case"callDirect":{const n=e.value;if(!(null!=n&&g(n)&&f(n.tryGetIndex(0))&&n.tryGetIndex(1)instanceof t))throw new Error(`${this.getScopeLine()}: Call direct needs an array of the function and num args code line input`);this.callFunction(n.tryGetIndex(0),n.tryGetIndex(1).value,!0);break}case"stringConcat":{if(!r(e.value))throw new Error(`${this.getScopeLine()}: StringConcat operator needs the number of args to concat`);const t=this.getArgs(e.value.value);this.pushStackString(t.value.join(""));break}case"+":this.pushStackNumber(this.getNumArg(e)+this.popStackNumber());break;case"-":{const t=this.getNumArg(e),n=this.popStackNumber();this.pushStackNumber(n-t);break}case"unaryNegative":this.pushStackNumber(-this.popStackNumber());break;case"*":this.pushStackNumber(this.getNumArg(e)*this.popStackNumber());break;case"/":{const t=this.getNumArg(e),n=this.popStackNumber();this.pushStackNumber(n/t);break}case"++":{if(null==e.value)throw new Error(`${this.getScopeLine()}: Inc operator needs code line variable`);const n=e.value.toString(),r=this._currentScope.getNumber(n);if(void 0===r)throw new Error(`${this.getScopeLine()}: Inc operator could not find variable: ${n}`);this._currentScope.set(n,new t(r+1));break}case"--":{if(null==e.value)throw new Error(`${this.getScopeLine()}: Dec operator needs code line variable`);const n=e.value.toString(),r=this._currentScope.getNumber(n);if(void 0===r)throw new Error(`${this.getScopeLine()}: Dec operator could not find variable: ${n}`);this._currentScope.set(n,new t(r-1));break}case"<":{const t=e.value??this.popStack(),n=this.popStack();this.pushStackBool(n.compareTo(t)<0);break}case"<=":{const t=e.value??this.popStack(),n=this.popStack();this.pushStackBool(n.compareTo(t)<=0);break}case"==":{const t=e.value??this.popStack(),n=this.popStack();this.pushStackBool(0==n.compareTo(t));break}case"!=":{const t=e.value??this.popStack(),n=this.popStack();this.pushStackBool(0!=n.compareTo(t));break}case">":{const t=e.value??this.popStack(),n=this.popStack();this.pushStackBool(n.compareTo(t)>0);break}case">=":{const t=e.value??this.popStack(),n=this.popStack();this.pushStackBool(n.compareTo(t)>=0);break}case"&&":this.pushStackBool(this.getBoolArg(e)&&this.popStackBool());break;case"||":this.pushStackBool(this.getBoolArg(e)||this.popStackBool());break;case"!":this.pushStackBool(!this.popStackBool())}}tryCallReturn(){const e=this._stackTrace.pop();return null!=e&&(this._currentScope=e.scope,this._lineCounter=e.lineNumber,this.currentCode=e.function,!0)}callReturn(){if(!this.tryCallReturn())throw new Error(`${this.getScopeLine()}: Unable to return, call stack empty`)}getArgs(e){if(0===e)return h.Empty;let t=!1;const n=new Array(e);for(let r=0;r<e;r++){const s=this.popStack();s instanceof h&&s.isArgumentValue&&(t=!0),n[e-r-1]=s}if(t){let e=[];for(const t of n)t instanceof h&&t.isArgumentValue?e=e.concat(t.value):e.push(t);return new h(e,!0)}return new h(n,!0)}getNumArg(e){if(null==e.value)return this.popStackNumber();if(r(e.value))return e.value.value;throw new Error(`${this.getScopeLine()}: Error attempt to get number argument`)}getBoolArg(e){if(null==e.value)return this.popStackBool();if(o(e.value))return e.value.value;throw new Error(`${this.getScopeLine()}: Error attempt to get boolean argument`)}jump(e){const t=this.currentCode.labels[e];if(null==t)throw new Error(`${this.getScopeLine()}: Unable to jump to label: ${e}`);this._lineCounter=t}callFunction(e,t,n){const r=this.getArgs(t);e.invoke(this,r,n)}executeFunction(e,t,n=!1){n&&this.pushCurrentToStackTrace(),this.currentCode=e,this._currentScope=new s(this._currentScope),this._lineCounter=0;const r=Math.min(t.value.length,e.parameters.length);let a=0;for(;a<r;a++){const n=e.parameters[a];if(n.startsWith("...")){t=d(t,a,-1),this._currentScope.define(n.substring(3),t),a++;break}this._currentScope.define(n,t.value[a])}if(a<e.parameters.length){const t=e.parameters[a];if(!t.startsWith("..."))throw new Error("Function called without enough arguments: "+e.name);this._currentScope.define(t.substring(3),h.Empty)}}pushCurrentToStackTrace(){this.pushToStackTrace({lineNumber:this._lineCounter,scope:this._currentScope,function:this.currentCode})}pushToStackTrace(e){if(this._stackTrace.length>=this._stackSize)throw new Error(`${this.getScopeLine()}: Unable to push to stack trace, stack is full`);this._stackTrace.push(e)}pushStack(e){if(this._stack.length>=this._stackSize)throw new Error(`${this.getScopeLine()}: Unable to push, stack full`);this._stack.push(e)}pushStackNumber(e){this.pushStack(new t(e))}pushStackString(e){this.pushStack(new u(e))}pushStackBool(e){this.pushStack(new a(e))}popStack(){const e=this._stack.pop();if(void 0===e)throw new Error(`${this.getScopeLine()}: Popped empty stack`);return e}popStackCast(e){const t=this.popStack();if(e(t))return t;throw new Error(`${this.getScopeLine()}: Pop stack cast error`)}popStackNumber(){const e=this._stack.pop();if(!r(e))throw new Error(`${this.getScopeLine()}: Pop stack error, not a number`);return e.value}popStackBool(){const e=this._stack.pop();if(!o(e))throw new Error(`${this.getScopeLine()}: Pop stack error, not a boolean`);return e.value}peekStack(){if(0===this._stack.length)throw new Error(`${this.getScopeLine()}: Peek empty stack`);return this._stack[this._stack.length-1]}createStackTrace(){const e=[this.debugScopeLine(this.currentCode,this._lineCounter-1)];for(let t=this.stackTrace.length-1;t>=0;t--){const n=this._stackTrace[t];e.push(this.debugScopeLine(n.function,n.lineNumber))}return e}debugScopeLine(e,t){if(t>=e.code.length)return`[${e.name}]:${t-1}: end of code`;if(t<0)return`[${e.name}]:${t-1}: before start of code`;const n=e.code[t],r=null!=n.value?n.value.toString():"<empty>";return`[${e.name}]:${t-1}:${n.operator}: [${r}]`}getScopeLine(){return`${this.currentCode.name}:${this._lineCounter}`}}function $(e){let t="\0",n=!1,r=!1,s="",a=0;const o=[];for(;a<e.length;){const i=e.charAt(a++);if(r)"\n"!==i&&"\r"!==i||(r=!1);else if("\0"!=t){if(n){switch(i){case'"':case"'":case"\\":s+=i;break;case"t":s+="\t";break;case"r":s+="\r";break;case"n":s+="\n"}n=!1;continue}if("\\"==i){n=!0;continue}s+=i,i==t&&(o.push(s),s="",t="\0")}else switch(i){case";":r=!0;break;case'"':case"'":t=i,s+=i;break;case"(":case")":case"{":case"}":s.length>0&&(o.push(s),s=""),o.push(i);break;case" ":case"\t":case"\n":case"\r":s.length>0&&(o.push(s),s="");break;default:s+=i}}return o}function E(e){const t=[];for(;e.length>0;)t.push(_(e));return new h(t)}function _(e){if(0===e.length)throw new Error("Unexpected end of tokens");const n=T(e);if("("===n){const t=[];for(;")"!==e[0];)t.push(_(e));return T(e),new h(t)}if(")"===n)throw new Error("Unexpected )");if("{"===n){const t={};for(;"}"!==e[0];){const n=_(e).toString(),r=_(e);t[n]=r}return T(e),new v(t)}if("}"===n)throw new Error("Unexpected }");return function(e){const n=parseFloat(e);if(!isNaN(n))return new t(n);if("true"===e)return a.True;if("false"===e)return a.False;if("null"===e)return S.Value;const r=e[0],s=e[e.length-1];return'"'===r&&'"'===s||"'"===r&&"'"===s?new u(e.substring(1,e.length-1)):new y(e)}(n)}function T(e){if(0===e.length)throw new Error("Unable to pop empty list");const t=e[0];return e.splice(0,1),t}class L{static Empty=new L(s.Empty,C.Empty);constructor(e,t){this.builtinScope=e,this.code=t}}class j{constructor(e){this.value=e}typename(){return"function"}toString(){return"function:"+this.value.name}compareTo(e){return this===e||e instanceof j&&this.value===e.value?0:1}invoke(e,t,n){e.executeFunction(this.value,t,n)}}function F(e,t){return{operator:e,value:t}}function P(e){return{label:e}}class A{builtinScope=new s;labelCount=0;loopStack=[];keywordParsingStack=[];parseFromText(e){const t=E($(e)),n=this.parseGlobalFunction(t),r=new s;return r.combineScope(this.builtinScope),new L(r,n)}parse(e){if(e instanceof h){if(0===e.value.length)return[];const t=e.value[0];if(t instanceof y){const n=t.toString();if(t.isLabel)return[P(n)];const r=this.parseKeyword(n,e);if(r.length>0)return r;this.keywordParsingStack.push("func-call");let s=e.value.slice(1).map((e=>this.parse(e))).flat(1);return s=s.concat(this.optimiseCallSymbolValue(t.value,e.value.length-1)),this.keywordParsingStack.pop(),s}}else if(e instanceof y&&!e.isLabel)return this.optimiseGetSymbolValue(e.value);return[F("push",e)]}parseDefineSet(e,t){const n=t?"define":"set",r=this.parse(e.value[e.value.length-1]);for(let t=e.value.length-2;t>=1;t--)r.push(F(n,e.value[t]));return r}parseLoop(e){if(e.value.length<3)throw new Error("Loop input has too few arguments");const t=this.labelCount++,n=`:LoopStart${t}`,r=`:LoopEnd${t}`;this.loopStack.push({start:n,end:r});const s=e.value[1];let a=[P(n),...this.parse(s)];a.push(F("jumpFalse",new u(r)));for(let t=2;t<e.value.length;t++)a=a.concat(this.parse(e.value[t]));return a.push(F("jump",new u(n))),a.push(P(r)),this.loopStack.pop(),a}parseCond(e,t){if(e.value.length<3)throw new Error("Condition input has too few inputs");if(e.value.length>4)throw new Error("Condition input has too many inputs!");const n=this.labelCount++,r=`:CondElse${n}`,s=`:CondEnd${n}`,a=4===e.value.length,o=t?"jumpFalse":"jumpTrue",i=e.value[1],c=e.value[2];let l=this.parse(i);if(a){l.push(F(o,new u(r))),l=l.concat(this.parseFlatten(c)),l.push(F("jump",new u(s))),l.push(P(r));const t=e.value[3];l=l.concat(this.parseFlatten(t))}else l.push(F(o,new u(s))),l=l.concat(this.parseFlatten(c));return l.push(P(s)),l}parseFlatten(e){return e.value.every(g)?e.value.map((e=>this.parse(e))).flat(1):this.parse(e)}parseLoopJump(e,t){if(0===this.loopStack.length)throw new Error(`Unexpected ${e} outside of loop`);const n=this.loopStack[this.loopStack.length-1];return[F("jump",new u(t?n.start:n.end))]}parseFunction(e){let t="",n=0;if((e.value[1]instanceof y||e.value[1]instanceof u)&&(t=e.value[1].toString(),n=1),!g(e.value[1+n]))throw new Error("Function needs parameter array");const r=e.value[1+n].arrayValues().map((e=>e.toString())),s=e.value.slice(2+n).map((e=>this.parse(e))).flat(1);return this.processTempFunction(r,s,t)}parseGlobalFunction(e){const t=e.value.map((e=>this.parse(e))).flat(1);return this.processTempFunction([],t,"global")}processTempFunction(e,t,n){const r={},s=[];for(const e of t)void 0!==e.label&&""!=e.label?r[e.label]=s.length:void 0!==e.operator&&s.push({operator:e.operator,value:e.value});return new C(s,e,r,n)}parseChangeVariable(e,n){const r=new u(e.toString());return[F("get",r),F("callDirect",new h([n,new t(1)])),F("set",r)]}parseJump(e){let t=this.parse(e.value[1]);return 1===t.length&&"push"===t[0].operator&&void 0!==t[0].value?[F("jump",t[0].value)]:(t.push(F("push")),t)}parseReturn(e){const t=e.value.slice(1).map((e=>this.parse(e))).flat(1);return t.push(F("return")),t}parseFunctionKeyword(e){const t=this.parseFunction(e),n=[F("push",new j(t))],r=this.keywordParsingStack.length>1?this.keywordParsingStack[this.keywordParsingStack.length-1]:"function";return t.hasName&&"function"===r&&n.push(F("define",new u(t.name))),n}parseNegative(e){if(e.value.length>=3)return this.parseOperator("-",e);if(2===e.value.length){if(r(e.value[1]))return[F("push",new t(-e.value[1].value))];const n=this.parse(e.value[1]);return n.push(F("unaryNegative")),n}throw new Error("Negative/Sub operator expects at least 1 input")}parseOnePushInput(e,t){if(t.value.length<2)throw new Error(`Expecting at least 1 input for: ${e}`);let n=[];for(let r=1;r<t.value.length;r++)n=n.concat(this.parse(t.value[r])),n.push(F(e));return n}parseOperator(e,t){if(t.value.length<3)throw new Error(`Expecting at least 3 inputs for: ${e}`);let n=this.parse(t.value[1]);for(let s=2;s<t.value.length;s++){const a=t.value[s];r(a)?n.push(F(e,a)):(n=n.concat(this.parse(a)),n.push(F(e)))}return n}parseOneVariableUpdate(e,t){if(t.value.length<2)throw new Error(`Expecting at least 1 input for: ${e}`);let n=[];for(let r=1;r<t.value.length;r++){const s=new u(t.value[r].toString());n.push(F(e,s))}return n}parseStringConcat(e){const n=e.value.slice(1).map((e=>this.parse(e))).flat(1);return n.push(F("stringConcat",new t(e.value.length-1))),n}transformAssignmentOperator(e){let t=e.value[0].toString();t=t.substring(0,t.length-1);const n=e.value[1].toString(),r=[...e.value];r[0]=new y(t);const s=[new y("set"),new y(n),new h(r)];return this.parse(new h(s))}parseKeyword(e,t){let n=null;switch(this.keywordParsingStack.push(e),e){case"function":n=this.parseFunctionKeyword(t);break;case"continue":n=this.parseLoopJump("continue",!0);break;case"break":n=this.parseLoopJump("break",!1);break;case"set":n=this.parseDefineSet(t,!1);break;case"define":n=this.parseDefineSet(t,!0);break;case"loop":n=this.parseLoop(t);break;case"if":n=this.parseCond(t,!0);break;case"unless":n=this.parseCond(t,!1);break;case"jump":n=this.parseJump(t);break;case"return":n=this.parseReturn(t);break;case"+":case"*":case"/":case"<":case"<=":case"==":case"!=":case">":case">=":case"&&":case"||":n=this.parseOperator(e,t);break;case"-":n=this.parseNegative(t);break;case"++":case"--":n=this.parseOneVariableUpdate(e,t);break;case"!":n=this.parseOnePushInput("!",t);break;case"$":n=this.parseStringConcat(t);break;case"+=":case"-=":case"*=":case"/=":case"&&=":case"||=":case"$=":n=this.transformAssignmentOperator(t)}return this.keywordParsingStack.pop(),null!=n?n:[]}optimiseCallSymbolValue(e,n){const r=new t(n),s=A.isGetPropertyRequest(e),a=this.builtinScope.get(s.parentKey);if(void 0!==a){let t;if(s.isPropertyRequest&&void 0!==(t=x(a,s.property))){if(f(t)){return[F("callDirect",new h([t,r]))]}throw new Error(`Attempting to call a value that is not a function: ${e} = ${t.toString()}`)}if(!s.isPropertyRequest){if(f(a)){return[F("callDirect",new h([a,r]))]}throw new Error(`Attempting to call a value that is not a function: ${e} = ${a.toString()}`)}}const o=[F("get",new u(s.parentKey))];return s.isPropertyRequest&&o.push(F("getProperty",s.property)),o.push(F("call",r)),o}optimiseGetSymbolValue(e){let t=!1;e.startsWith("...")&&(t=!0,e=e.substring(3));const n=[],r=A.isGetPropertyRequest(e),s=this.builtinScope.get(r.parentKey);if(void 0!==s)if(r.isPropertyRequest){const e=x(s,r.property);void 0!==e?n.push(F("push",e)):(n.push(F("push",s)),n.push(F("getProperty",r.property)))}else r.isPropertyRequest||n.push(F("push",s));else n.push(F("get",new u(r.parentKey))),r.isPropertyRequest&&n.push(F("getProperty",r.property));return t&&n.push(F("toArgument",void 0)),n}static isGetPropertyRequest(e){if(e.includes(".")){const t=e.split(".");return{isPropertyRequest:!0,parentKey:t[0],property:new h(t.slice(1).map((e=>new y(e))))}}return{isPropertyRequest:!1,parentKey:e,property:h.Empty}}}const V=Math.PI/180,B=function(){const n=new s,a={E:new t(Math.E),PI:new t(Math.PI),DegToRad:new t(V),sin:new e(((e,t)=>{e.pushStackNumber(Math.sin(t.getNumber(0)))}),"math.sin"),cos:new e(((e,t)=>{e.pushStackNumber(Math.cos(t.getNumber(0)))}),"math.cos"),tan:new e(((e,t)=>{e.pushStackNumber(Math.tan(t.getNumber(0)))}),"math.tan"),exp:new e(((e,t)=>{e.pushStackNumber(Math.exp(t.getNumber(0)))}),"math.exp"),ceil:new e(((e,t)=>{e.pushStackNumber(Math.ceil(t.getNumber(0)))}),"math.ceil"),floor:new e(((e,t)=>{e.pushStackNumber(Math.floor(t.getNumber(0)))}),"math.floor"),round:new e(((e,t)=>{e.pushStackNumber(Math.round(t.getNumber(0)))}),"math.round"),isFinite:new e(((e,t)=>{e.pushStackBool(Number.isFinite(t.getNumber(0)))}),"math.isFinite"),isNaN:new e(((e,t)=>{e.pushStackBool(isNaN(t.getNumber(0)))}),"math.isNaN"),parse:new e(((e,t)=>{const n=t.getIndex(0);r(n)?e.pushStack(n):e.pushStackNumber(parseFloat(n.toString()))}),"math.parse"),log:new e(((e,t)=>{e.pushStackNumber(Math.log(t.getNumber(0)))}),"math.log"),abs:new e(((e,t)=>{e.pushStackNumber(Math.abs(t.getNumber(0)))}),"math.abs"),max:new e(((e,t)=>{let n=t.value[0];for(let e=1;e<t.value.length;e++){const r=t.value[e];r.compareTo(n)>0&&(n=r)}e.pushStack(n)}),"math.max"),min:new e(((e,t)=>{let n=t.value[0];for(let e=1;e<t.value.length;e++){const r=t.value[e];r.compareTo(n)<0&&(n=r)}e.pushStack(n)}),"math.min"),sum:new e(((e,t)=>{let n=0;for(let e=0;e<t.value.length;e++){const s=t.value[e];if(!r(s))throw new Error("Addition operator expects all numbers");n+=s.value}e.pushStackNumber(n)}),"math.sum")};return n.define("math",new v(a)),n}();const K=function(){const t=new s,n={join:new e(((e,t)=>{if(t.value.length<2)throw new Error("Not enough arguments for string join");const n=t.value[0],r=t.value.slice(1).join(n.toString());e.pushStackString(r)}),"string.join"),length:new e(((e,t)=>{const n=t.getString(0);e.pushStackNumber(n.length)}),"string.length"),get:new e(((e,t)=>{const n=t.getIndexCast(0,c),r=t.getNumber(1);e.pushStackString(n.value[n.getIndex(r)])}),"string.get"),set:new e(((e,t)=>{const n=t.getIndexCast(0,c),r=t.getNumber(1),s=t.getIndex(2).toString();e.pushStack(function(e,t,n){return t=e.getIndex(t),new u(`${e.value.substring(0,t)}${n}${e.value.substring(t+1)}`)}(n,r,s))}),"string.set"),insert:new e(((e,t)=>{const n=t.getIndexCast(0,c),r=t.getNumber(1),s=t.getIndex(2).toString();e.pushStack(function(e,t,n){return t=e.getIndex(t),new u(`${e.value.substring(0,t)}${n}${e.value.substring(t)}`)}(n,r,s))}),"string.insert"),substring:new e(((e,t)=>{const n=t.getIndexCast(0,c),r=t.getNumber(1),s=t.getNumber(2);e.pushStack(function(e,t,n){return t=e.getIndex(t),new u(e.value.substring(t,t+n))}(n,r,s))}),"string.substring"),removeAt:new e(((e,t)=>{const n=t.getIndexCast(0,c),r=t.getNumber(1);e.pushStack(function(e,t){return t=e.getIndex(t),new u(`${e.value.substring(0,t)}${e.value.substring(t+1)}`)}(n,r))}),"string.removeAt"),removeAll:new e(((e,t)=>{const n=t.getIndexCast(0,c),r=t.getIndex(1).toString();e.pushStack(function(e,t){return new u(e.value.replace(t,""))}(n,r))}),"string.removeAll")};return t.define("string",new v(n)),t}();const R=function(){const t=new s,n={set:new e(((e,t)=>{const n=t.getIndexCast(0,m),r=t.getString(1),s=t.getIndex(2);e.pushStack(function(e,t,n){return new v({...e.value,[t]:n})}(n,r,s))}),"object.set"),get:new e(((e,t)=>{const n=function(e,t){const n=e.value[t];return null!=n?n:void 0}(t.getIndexCast(0,m),t.getString(1));void 0!==n?e.pushStack(n):e.pushStack(S.Value)}),"object.get"),removeKey:new e(((e,t)=>{const n=t.getIndexCast(0,m),r=t.getString(1);e.pushStack(function(e,t){if(!e.value.hasOwnProperty(t))return e;const n={...e.value};return delete n[t],new v(n)}(n,r))}),"object.removeKey"),removeValues:new e(((e,t)=>{const n=t.getIndexCast(0,m),r=t.getIndex(1);e.pushStack(function(e,t){const n={};for(const r in e.value)0!==e.value[r].compareTo(t)&&(n[r]=e.value[r]);return new v(n)}(n,r))}),"object.removeValues"),keys:new e(((e,t)=>{const n=t.getIndexCast(0,m);e.pushStack(new h(n.keys.map((e=>new u(e)))))}),"object.keys"),values:new e(((e,t)=>{const n=t.getIndexCast(0,m);var r;e.pushStack((r=n,new h(Object.values(r.value))))}),"object.values"),length:new e(((e,t)=>{const n=t.getIndexCast(0,m);e.pushStackNumber(n.keys.length)}),"object.length")};return t.define("object",new v(n)),t}();const U=function(){const e=new s;return e.defineFunc("toString",((e,t)=>{e.pushStackString(t.getIndex(0).toString())})),e.defineFunc("typeof",((e,t)=>{e.pushStackString(t.getIndex(0).typename())})),e.defineFunc("compareTo",((e,t)=>{e.pushStackNumber(t.getIndex(0).compareTo(t.getIndex(1)))})),e.defineFunc("print",((e,t)=>{console.log(t.value.map((e=>e.toString())).join(""))})),e}();let G;var M;(M=G||(G={}))[M.math=1]="math",M[M.string=2]="string",M[M.array=4]="array",M[M.object=8]="object",M[M.misc=16]="misc",M[M.all=31]="all",globalThis.run=function(e){const t=document.getElementById(e),n=document.getElementById(e+"_output");null!=t&&null!=n||alert("Broken code example, unable to find code id: "+e);const r=t?.value;if(!r)return void(n.innerHTML="Needs text input to parse");n.innerHTML="";const s=new A;var a,o;a=s.builtinScope,(o=G.all)&G.math&&a.combineScope(B),o&G.string&&a.combineScope(K),o&G.array&&a.combineScope(k),o&G.object&&a.combineScope(R),o&G.misc&&a.combineScope(U),s.builtinScope.defineFunc("print",((e,t)=>{const r=t.value.map((e=>e.toString())).join("");console.log(r),n.innerHTML+=r+"<br/>"}));const i=s.parseFromText(r);new I(16).execute(i)};
//# sourceMappingURL=index.e507f571.js.map
